(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{"12Lf":function(e,t,o){"use strict";o.r(t),o.d(t,"GraphqlModule",(function(){return Y}));var n=o("ofXK"),a=o("tyNb"),r=o("PCNd"),c=o("Ydvz"),s=o("fXoL"),l=o("zg9e"),i=o("FKbk"),b=o("xE8d");let p=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return d(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-cli-plugin"]],features:[s.tb],decls:165,vars:8,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/cli-plugin.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","cli-plugin"],[1,"warning"],[1,"info"],["appAnchor","","id","overview"],[1,"filename"],["app48413e81c1bcc86f84e75009a7b86777c75e1991",""],[1,"language-typescript"],["app7a034e34c3854c1dead7f26e82c2b1dcc2390a03",""],["appAnchor","","id","using-the-cli-plugin"],["routerLink","/cli/overview"],[1,"language-javascript"]],template:function(e,t){if(1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"CLI Plugin"),s.Hb(),s.Ib(7,"blockquote",6),s.Ib(8,"strong"),s.lc(9,"Warning"),s.Hb(),s.lc(10," This chapter applies only to the code first approach.\n"),s.Hb(),s.Ib(11,"p"),s.lc(12,"TypeScript's metadata reflection system has several limitations which make it impossible to, for instance, determine what properties a class consists of or recognize whether a given property is optional or required. However, some of these constraints can be addressed at compilation time. Nest provides a plugin that enhances the TypeScript compilation process to reduce the amount of boilerplate code required."),s.Hb(),s.Ib(13,"blockquote",7),s.Ib(14,"strong"),s.lc(15,"Hint"),s.Hb(),s.lc(16," This plugin is "),s.Ib(17,"strong"),s.lc(18,"opt-in"),s.Hb(),s.lc(19,". If you prefer, you can declare all decorators manually, or only specific decorators where you need them.\n"),s.Hb(),s.Ib(20,"h4",8),s.Ib(21,"span"),s.lc(22,"Overview"),s.Hb(),s.Hb(),s.Ib(23,"p"),s.lc(24,"The GraphQL plugin will automatically:"),s.Hb(),s.Ib(25,"ul"),s.Ib(26,"li"),s.lc(27,"annotate all input object, object type and args classes properties with "),s.Ib(28,"code"),s.lc(29,"@Field"),s.Hb(),s.lc(30," unless "),s.Ib(31,"code"),s.lc(32,"@HideField"),s.Hb(),s.lc(33," is used"),s.Hb(),s.Ib(34,"li"),s.lc(35,"set the "),s.Ib(36,"code"),s.lc(37,"nullable"),s.Hb(),s.lc(38," property depending on the question mark (e.g. "),s.Ib(39,"code"),s.lc(40,"name?: string"),s.Hb(),s.lc(41," will set "),s.Ib(42,"code"),s.lc(43,"nullable: true"),s.Hb(),s.lc(44,")"),s.Hb(),s.Ib(45,"li"),s.lc(46,"set the "),s.Ib(47,"code"),s.lc(48,"type"),s.Hb(),s.lc(49," property depending on the type (supports arrays as well)"),s.Hb(),s.Hb(),s.Ib(50,"p"),s.lc(51,"Please, note that your filenames "),s.Ib(52,"strong"),s.lc(53,"must have"),s.Hb(),s.lc(54," one of the following suffixes in order to be analyzed by the plugin: "),s.Ib(55,"code"),s.lc(56,"['.input.ts', '.args.ts', '.entity.ts', '.model.ts']"),s.Hb(),s.lc(57," (e.g., "),s.Ib(58,"code"),s.lc(59,"author.entity.ts"),s.Hb(),s.lc(60,"). If you are using a different suffix, you can adjust the plugin's behavior by specifying the "),s.Ib(61,"code"),s.lc(62,"typeFileNameSuffix"),s.Hb(),s.lc(63," option (see below)."),s.Hb(),s.Ib(64,"p"),s.lc(65,"With what we've learned so far, you have to duplicate a lot of code to let the package know how your type should be declared in GraphQL. For example, you could define a simple "),s.Ib(66,"code"),s.lc(67,"Author"),s.Hb(),s.lc(68," class as follows:"),s.Hb(),s.Ib(69,"span",9),s.lc(70),s.Ub(71,"extension"),s.Gb(72,"app-tabs",null,10),s.Hb(),s.Ib(74,"pre"),s.Ib(75,"code",11),s.lc(76,"\n@ObjectType()\nexport class Author {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ nullable: true })\n  lastName?: string;\n\n  @Field(type => [Post])\n  posts: Post[];\n}"),s.Hb(),s.Hb(),s.Ib(77,"p"),s.lc(78,"While not a significant issue with medium-sized projects, it becomes verbose & hard to maintain once you have a large set of classes."),s.Hb(),s.Ib(79,"p"),s.lc(80,"By enabling the GraphQL plugin, the above class definition can be declared simply:"),s.Hb(),s.Ib(81,"span",9),s.lc(82),s.Ub(83,"extension"),s.Gb(84,"app-tabs",null,12),s.Hb(),s.Ib(86,"pre"),s.Ib(87,"code",11),s.lc(88,"\n@ObjectType()\nexport class Author {\n  @Field(type => Int)\n  id: number;\n  firstName?: string;\n  lastName?: string;\n  posts: Post[];\n}"),s.Hb(),s.Hb(),s.Ib(89,"p"),s.lc(90,"The plugin adds appropriate decorators on-the-fly based on the "),s.Ib(91,"strong"),s.lc(92,"Abstract Syntax Tree"),s.Hb(),s.lc(93,". Thus, you won't have to struggle with "),s.Ib(94,"code"),s.lc(95,"@Field"),s.Hb(),s.lc(96," decorators scattered throughout the code."),s.Hb(),s.Ib(97,"blockquote",7),s.Ib(98,"strong"),s.lc(99,"Hint"),s.Hb(),s.lc(100," The plugin will automatically generate any missing swagger properties, but if you need to override them, simply set them explicitly via "),s.Ib(101,"code"),s.lc(102,"@Field()"),s.Hb(),s.lc(103,".\n"),s.Hb(),s.Ib(104,"h4",13),s.Ib(105,"span"),s.lc(106,"Using the CLI plugin"),s.Hb(),s.Hb(),s.Ib(107,"p"),s.lc(108,"To enable the plugin, open "),s.Ib(109,"code"),s.lc(110,"nest-cli.json"),s.Hb(),s.lc(111," (if you use "),s.Ib(112,"a",14),s.lc(113,"Nest CLI"),s.Hb(),s.lc(114,") and add the following "),s.Ib(115,"code"),s.lc(116,"plugins"),s.Hb(),s.lc(117," configuration:"),s.Hb(),s.Ib(118,"pre"),s.Ib(119,"code",15),s.lc(120,'\n{\n  "collection": "@nestjs/schematics",\n  "sourceRoot": "src",\n  "compilerOptions": {\n    "plugins": ["@nestjs/graphql/plugin"]\n  }\n}'),s.Hb(),s.Hb(),s.Ib(121,"p"),s.lc(122,"You can use the "),s.Ib(123,"code"),s.lc(124,"options"),s.Hb(),s.lc(125," property to customize the behavior of the plugin."),s.Hb(),s.Ib(126,"pre"),s.Ib(127,"code",15),s.lc(128,'\n"plugins": [\n  {\n    "name": "@nestjs/graphql/plugin",\n    "options": {\n      "typeFileNameSuffix": [".input.ts", ".args.ts"]\n    }\n  }\n]'),s.Hb(),s.Hb(),s.Ib(129,"p"),s.lc(130,"The "),s.Ib(131,"code"),s.lc(132,"options"),s.Hb(),s.lc(133," property has to fulfill the following interface:"),s.Hb(),s.Ib(134,"pre"),s.Ib(135,"code",11),s.lc(136,"\nexport interface PluginOptions {\n  typeFileNameSuffix?: string[];\n}"),s.Hb(),s.Hb(),s.Ib(137,"table"),s.Ib(138,"tr"),s.Ib(139,"th"),s.lc(140,"Option"),s.Hb(),s.Ib(141,"th"),s.lc(142,"Default"),s.Hb(),s.Ib(143,"th"),s.lc(144,"Description"),s.Hb(),s.Hb(),s.Ib(145,"tr"),s.Ib(146,"td"),s.Ib(147,"code"),s.lc(148,"typeFileNameSuffix"),s.Hb(),s.Hb(),s.Ib(149,"td"),s.Ib(150,"code"),s.lc(151,"['.input.ts', '.args.ts', '.entity.ts', '.model.ts']"),s.Hb(),s.Hb(),s.Ib(152,"td"),s.lc(153,"GraphQL types files suffix"),s.Hb(),s.Hb(),s.Hb(),s.Ib(154,"p"),s.lc(155,"If you don't use the CLI but instead have a custom "),s.Ib(156,"code"),s.lc(157,"webpack"),s.Hb(),s.lc(158," configuration, you can use this plugin in combination with "),s.Ib(159,"code"),s.lc(160,"ts-loader"),s.Hb(),s.lc(161,":"),s.Hb(),s.Ib(162,"pre"),s.Ib(163,"code",15),s.lc(164,"\ngetCustomTransformers: (program: any) => ({\n  before: [require('@nestjs/graphql/plugin').before({}, program)]\n}),"),s.Hb(),s.Hb(),s.Hb()),2&e){const e=s.dc(73),t=s.dc(85);s.vb(70),s.nc(" ",s.Vb(71,2,"authors/models/author.model",e.isJsActive),"\n"),s.vb(12),s.nc(" ",s.Vb(83,5,"authors/models/author.model",t.isJsActive),"\n")}},directives:[l.a,i.a,a.f],pipes:[b.a],encapsulation:2,changeDetection:0}),e})();const d=s.Kb(p);let h=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return u(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-complexity"]],features:[s.tb],decls:89,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/complexity.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","complexity"],[1,"warning"],["rel","nofollow","target","_blank","href","https://github.com/slicknode/graphql-query-complexity"],["appAnchor","","id","installation"],[1,"language-bash"],["appAnchor","","id","getting-started"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","field-level-complexity"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Complexity"),s.Hb(),s.Ib(7,"blockquote",6),s.Ib(8,"strong"),s.lc(9,"Warning"),s.Hb(),s.lc(10," This chapter applies only to the code first approach.\n"),s.Hb(),s.Ib(11,"p"),s.lc(12,"Query complexity allows you to define how complex certain fields are, and to restrict queries with a "),s.Ib(13,"strong"),s.lc(14,"maximum complexity"),s.Hb(),s.lc(15,". The idea is to define how complex each field is by using a simple number. A common default is to give each field a complexity of "),s.Ib(16,"code"),s.lc(17,"1"),s.Hb(),s.lc(18,". In addition, the complexity calculation of a GraphQL query can be customized with so-called complexity estimators. A complexity estimator is a simple function that calculates the complexity for a field. You can add any number of complexity estimators to the rule, which are then executed one after another. The first estimator that returns a numeric complexity value determines the complexity for that field."),s.Hb(),s.Ib(19,"p"),s.lc(20,"The "),s.Ib(21,"code"),s.lc(22,"@nestjs/graphql"),s.Hb(),s.lc(23," package integrates very well with tools like "),s.Ib(24,"a",7),s.lc(25,"graphql-query-complexity"),s.Hb(),s.lc(26," that provides a cost analysis-based solution. With this library, you can reject queries to your GraphQL server that are deemed too costly to execute."),s.Hb(),s.Ib(27,"h4",8),s.Ib(28,"span"),s.lc(29,"Installation"),s.Hb(),s.Hb(),s.Ib(30,"p"),s.lc(31,"To begin using it, we first install the required dependency."),s.Hb(),s.Ib(32,"pre"),s.Ib(33,"code",9),s.lc(34,"\n$ npm install --save graphql-query-complexity"),s.Hb(),s.Hb(),s.Ib(35,"h4",10),s.Ib(36,"span"),s.lc(37,"Getting started"),s.Hb(),s.Hb(),s.Ib(38,"p"),s.lc(39,"Once the installation process is complete, we can define the "),s.Ib(40,"code"),s.lc(41,"ComplexityPlugin"),s.Hb(),s.lc(42," class:"),s.Hb(),s.Ib(43,"pre"),s.Ib(44,"code",11),s.lc(45,"\nimport { GraphQLSchemaHost, Plugin } from '@nestjs/graphql';\nimport {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n} from 'apollo-server-plugin-base';\nimport { GraphQLError } from 'graphql';\nimport {\n  fieldExtensionsEstimator,\n  getComplexity,\n  simpleEstimator,\n} from 'graphql-query-complexity';\n\n@Plugin()\nexport class ComplexityPlugin implements ApolloServerPlugin {\n  constructor(private gqlSchemaHost: GraphQLSchemaHost) {}\n\n  requestDidStart(): GraphQLRequestListener {\n    const { schema } = this.gqlSchemaHost;\n\n    return {\n      didResolveOperation({ request, document }) {\n        const complexity = getComplexity({\n          schema,\n          operationName: request.operationName,\n          query: document,\n          variables: request.variables,\n          estimators: [\n            fieldExtensionsEstimator(),\n            simpleEstimator({ defaultComplexity: 1 }),\n          ],\n        });\n        if (complexity >= 20) {\n          throw new GraphQLError(\n            `Query is too complex: ${complexity}. Maximum allowed complexity: 20`,\n          );\n        }\n        console.log('Query Complexity:', complexity);\n      },\n    };\n  }\n}"),s.Hb(),s.Hb(),s.Ib(46,"p"),s.lc(47,"For demonstration purposes, we specified the maximum allowed complexity as "),s.Ib(48,"code"),s.lc(49,"20"),s.Hb(),s.lc(50,". In the example above, we used 2 estimators, the "),s.Ib(51,"code"),s.lc(52,"simpleEstimator"),s.Hb(),s.lc(53," and the "),s.Ib(54,"code"),s.lc(55,"fieldExtensionsEstimator"),s.Hb(),s.lc(56,"."),s.Hb(),s.Ib(57,"ul"),s.Ib(58,"li"),s.Ib(59,"code"),s.lc(60,"simpleEstimator"),s.Hb(),s.lc(61,": the simple estimator returns a fixed complexity for each field"),s.Hb(),s.Ib(62,"li"),s.Ib(63,"code"),s.lc(64,"fieldExtensionsEstimator"),s.Hb(),s.lc(65,": the field extensions estimator extracts the complexity value for each field of your schema"),s.Hb(),s.Hb(),s.Ib(66,"blockquote",12),s.Ib(67,"strong"),s.lc(68,"Hint"),s.Hb(),s.lc(69," Remember to add this class to the providers array in any module.\n"),s.Hb(),s.Ib(70,"h4",13),s.Ib(71,"span"),s.lc(72,"Field-level complexity"),s.Hb(),s.Hb(),s.Ib(73,"p"),s.lc(74,"With this plugin in place, we can now define the complexity for any field by specifying the "),s.Ib(75,"code"),s.lc(76,"complexity"),s.Hb(),s.lc(77," property in the options object passed into the "),s.Ib(78,"code"),s.lc(79,"@Field()"),s.Hb(),s.lc(80," decorator, as follows:"),s.Hb(),s.Ib(81,"pre"),s.Ib(82,"code",11),s.lc(83,"\n@Field({ complexity: 3 })\ntitle: string;"),s.Hb(),s.Hb(),s.Ib(84,"p"),s.lc(85,"Alternatively, you can define the estimator function:"),s.Hb(),s.Ib(86,"pre"),s.Ib(87,"code",11),s.lc(88,"\n@Field({ complexity: (options: ComplexityEstimatorArgs) => ... })\ntitle: string;"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const u=s.Kb(h);let I=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return m(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-directives"]],features:[s.tb],decls:106,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/directives.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","directives"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/queries/#directives"],["appAnchor","","id","custom-directives"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","code-first"],["appAnchor","","id","schema-first"],[1,"language-graphql"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Directives"),s.Hb(),s.Ib(7,"p"),s.lc(8,"A directive can be attached to a field or fragment inclusion, and can affect execution of the query in any way the server desires (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,"). The GraphQL specification provides several default directives:"),s.Hb(),s.Ib(12,"ul"),s.Ib(13,"li"),s.Ib(14,"code"),s.lc(15,"@include(if: Boolean)"),s.Hb(),s.lc(16," - only include this field in the result if the argument is true"),s.Hb(),s.Ib(17,"li"),s.Ib(18,"code"),s.lc(19,"@skip(if: Boolean)"),s.Hb(),s.lc(20," - skip this field if the argument is true"),s.Hb(),s.Ib(21,"li"),s.Ib(22,"code"),s.lc(23,"@deprecated(reason: String)"),s.Hb(),s.lc(24," - marks field as deprecated with message"),s.Hb(),s.Hb(),s.Ib(25,"p"),s.lc(26,"A directive is an identifier preceded by a "),s.Ib(27,"code"),s.lc(28,"@"),s.Hb(),s.lc(29," character, optionally followed by a list of named arguments, which can appear after almost any element in the GraphQL query and schema languages."),s.Hb(),s.Ib(30,"h4",7),s.Ib(31,"span"),s.lc(32,"Custom directives"),s.Hb(),s.Hb(),s.Ib(33,"p"),s.lc(34,"To create a custom schema directive, declare a class which extends the "),s.Ib(35,"code"),s.lc(36,"SchemaDirectiveVisitor"),s.Hb(),s.lc(37," class exported from the "),s.Ib(38,"code"),s.lc(39,"apollo-server"),s.Hb(),s.lc(40," package."),s.Hb(),s.Ib(41,"pre"),s.Ib(42,"code",8),s.lc(43,"\nimport { SchemaDirectiveVisitor } from 'apollo-server';\nimport { defaultFieldResolver, GraphQLField } from 'graphql';\n\nexport class UpperCaseDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field: GraphQLField<any, any>) {\n    const { resolve = defaultFieldResolver } = field;\n    field.resolve = async function(...args) {\n      const result = await resolve.apply(this, args);\n      if (typeof result === 'string') {\n        return result.toUpperCase();\n      }\n      return result;\n    };\n  }\n}"),s.Hb(),s.Hb(),s.Ib(44,"blockquote",9),s.Ib(45,"strong"),s.lc(46,"Hint"),s.Hb(),s.lc(47," Note that directives cannot be decorated with the "),s.Ib(48,"code"),s.lc(49,"@Injectable()"),s.Hb(),s.lc(50," decorator. Thus, they are not able to inject dependencies.\n"),s.Hb(),s.Ib(51,"p"),s.lc(52,"Now, register the "),s.Ib(53,"code"),s.lc(54,"UpperCaseDirective"),s.Hb(),s.lc(55," in the "),s.Ib(56,"code"),s.lc(57,"GraphQLModule.forRoot()"),s.Hb(),s.lc(58," method:"),s.Hb(),s.Ib(59,"pre"),s.Ib(60,"code",8),s.lc(61,"\nGraphQLModule.forRoot({\n  // ...\n  schemaDirectives: {\n    upper: UpperCaseDirective,\n  },\n});"),s.Hb(),s.Hb(),s.Ib(62,"p"),s.lc(63,"Once registered, the "),s.Ib(64,"code"),s.lc(65,"@upper"),s.Hb(),s.lc(66," directive can be used in our schema. However, the way you apply the directive will vary depending on the approach you use (code first or schema first)."),s.Hb(),s.Ib(67,"h4",10),s.Ib(68,"span"),s.lc(69,"Code first"),s.Hb(),s.Hb(),s.Ib(70,"p"),s.lc(71,"In the code first approach, use the "),s.Ib(72,"code"),s.lc(73,"@Directive()"),s.Hb(),s.lc(74," decorator to apply the directive."),s.Hb(),s.Ib(75,"pre"),s.Ib(76,"code",8),s.lc(77,"\n@Directive('@upper')\n@Field()\ntitle: string;"),s.Hb(),s.Hb(),s.Ib(78,"blockquote",9),s.Ib(79,"strong"),s.lc(80,"Hint"),s.Hb(),s.lc(81," The "),s.Ib(82,"code"),s.lc(83,"@Directive()"),s.Hb(),s.lc(84," decorator is exported from the "),s.Ib(85,"code"),s.lc(86,"@nestjs/graphql"),s.Hb(),s.lc(87," package.\n"),s.Hb(),s.Ib(88,"p"),s.lc(89,"Directives can be applied on fields, field resolvers, input and object types, as well as queries, mutations, and subscriptions. Here's an example of the directive applied on the query handler level:"),s.Hb(),s.Ib(90,"pre"),s.Ib(91,"code",8),s.lc(92,"\n@Directive('@deprecated(reason: \"This query will be removed in the next version\")')\n@Query(returns => Author, { name: 'author' })\nasync getAuthor(@Args({ name: 'id', type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}"),s.Hb(),s.Hb(),s.Ib(93,"p"),s.lc(94,"Directives applied through the "),s.Ib(95,"code"),s.lc(96,"@Directive()"),s.Hb(),s.lc(97," decorator will not be reflected in the generated schema definition file."),s.Hb(),s.Ib(98,"h4",11),s.Ib(99,"span"),s.lc(100,"Schema first"),s.Hb(),s.Hb(),s.Ib(101,"p"),s.lc(102,"In the schema first approach, apply directives directly in SDL."),s.Hb(),s.Ib(103,"pre"),s.Ib(104,"code",12),s.lc(105,"\ndirective @upper on FIELD_DEFINITION\n\ntype Post {\n  id: Int!\n  title: String! @upper\n  votes: Int\n}"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const m=s.Kb(I);let H=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return g(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-enums"]],features:[s.tb],decls:103,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/enums.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","enums"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#enumeration-types"],["appAnchor","","id","code-first"],[1,"language-typescript"],[1,"language-graphql"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/scalars-enums/#internal-values"],[1,"info"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Enums"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,"). This allows you to:"),s.Hb(),s.Ib(12,"ul"),s.Ib(13,"li"),s.lc(14,"validate that any arguments of this type are one of the allowed values"),s.Hb(),s.Ib(15,"li"),s.lc(16,"communicate through the type system that a field will always be one of a finite set of values"),s.Hb(),s.Hb(),s.Ib(17,"h4",7),s.Ib(18,"span"),s.lc(19,"Code first"),s.Hb(),s.Hb(),s.Ib(20,"p"),s.lc(21,"When using the code first approach, you define a GraphQL enum type by simply creating a TypeScript enum."),s.Hb(),s.Ib(22,"pre"),s.Ib(23,"code",8),s.lc(24,"\nexport enum AllowedColor {\n  RED,\n  GREEN,\n  BLUE,\n}"),s.Hb(),s.Hb(),s.Ib(25,"p"),s.lc(26,"With this in place, register the "),s.Ib(27,"code"),s.lc(28,"AllowedColor"),s.Hb(),s.lc(29," enum using the "),s.Ib(30,"code"),s.lc(31,"registerEnumType"),s.Hb(),s.lc(32," function exported from the "),s.Ib(33,"code"),s.lc(34,"@nestjs/graphql"),s.Hb(),s.lc(35," package:"),s.Hb(),s.Ib(36,"pre"),s.Ib(37,"code",8),s.lc(38,"\nregisterEnumType(AllowedColor, {\n  name: 'AllowedColor',\n});"),s.Hb(),s.Hb(),s.Ib(39,"p"),s.lc(40,"Now you can reference the "),s.Ib(41,"code"),s.lc(42,"AllowedColor"),s.Hb(),s.lc(43," in our types:"),s.Hb(),s.Ib(44,"pre"),s.Ib(45,"code",8),s.lc(46,"\n@Field(type => AllowedColor)\nfavoriteColor: AllowedColor;"),s.Hb(),s.Hb(),s.Ib(47,"p"),s.lc(48,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(49,"pre"),s.Ib(50,"code",9),s.lc(51,"\nenum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}"),s.Hb(),s.Hb(),s.Ib(52,"h4",10),s.Ib(53,"span"),s.lc(54,"Schema first"),s.Hb(),s.Hb(),s.Ib(55,"p"),s.lc(56,"To define an enumerator in the schema first approach, simply create a GraphQL enum with SDL."),s.Hb(),s.Ib(57,"pre"),s.Ib(58,"code",9),s.lc(59,"\nenum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}"),s.Hb(),s.Hb(),s.Ib(60,"p"),s.lc(61,"Then you can use the typings generation feature (as shown in the "),s.Ib(62,"a",11),s.lc(63,"quick start"),s.Hb(),s.lc(64," chapter) to generate corresponding TypeScript definitions:"),s.Hb(),s.Ib(65,"pre"),s.Ib(66,"code",8),s.lc(67,"\nexport enum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}"),s.Hb(),s.Hb(),s.Ib(68,"p"),s.lc(69,"Sometimes a backend forces a different value for an enum internally than in the public API. In this example the API contains "),s.Ib(70,"code"),s.lc(71,"RED"),s.Hb(),s.lc(72,", however in resolvers we may use "),s.Ib(73,"code"),s.lc(74,"#f00"),s.Hb(),s.lc(75," instead (read more "),s.Ib(76,"a",12),s.lc(77,"here"),s.Hb(),s.lc(78,"). To accomplish this, declare a resolver object for the "),s.Ib(79,"code"),s.lc(80,"AllowedColor"),s.Hb(),s.lc(81," enum:"),s.Hb(),s.Ib(82,"pre"),s.Ib(83,"code",8),s.lc(84,"\nexport const allowedColorResolver: Record<keyof typeof AllowedColor, any> = {\n  RED: '#f00',\n}"),s.Hb(),s.Hb(),s.Ib(85,"blockquote",13),s.Ib(86,"strong"),s.lc(87,"Hint"),s.Hb(),s.lc(88," All decorators are exported from the "),s.Ib(89,"code"),s.lc(90,"@nestjs/graphql"),s.Hb(),s.lc(91," package.\n"),s.Hb(),s.Ib(92,"p"),s.lc(93,"Then use this resolver object together with the "),s.Ib(94,"code"),s.lc(95,"resolvers"),s.Hb(),s.lc(96," property of the "),s.Ib(97,"code"),s.lc(98,"GraphQLModule#forRoot()"),s.Hb(),s.lc(99," method, as follows:"),s.Hb(),s.Ib(100,"pre"),s.Ib(101,"code",8),s.lc(102,"\nGraphQLModule.forRoot({\n  resolvers: {\n    AllowedColor: allowedColorResolver,\n  },\n})"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a,a.f],encapsulation:2,changeDetection:0}),e})();const g=s.Kb(H);let f=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return y(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-extensions"]],features:[s.tb],decls:103,vars:2,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/extensions.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","extensions"],[1,"warning"],["appAnchor","","id","adding-custom-metadata"],[1,"language-typescript"],["appAnchor","","id","using-custom-metadata"],["rel","nofollow","target","_blank","href","https://github.com/robrichard/graphql-fields"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Extensions"),s.Hb(),s.Ib(7,"blockquote",6),s.Ib(8,"strong"),s.lc(9,"Warning"),s.Hb(),s.lc(10," This chapter applies only to the code first approach.\n"),s.Hb(),s.Ib(11,"p"),s.lc(12,"Extensions is an "),s.Ib(13,"strong"),s.lc(14,"advanced, low-level feature"),s.Hb(),s.lc(15," that lets you define arbitrary data in the types configuration. Attaching custom metadata to certain fields allows you to create more sophisticated, generic solutions. For example, with extensions, you can define field-level roles required to access particular fields. Such roles can be reflected at runtime to determine whether the caller has sufficient permissions to retrieve a specific field."),s.Hb(),s.Ib(16,"h4",7),s.Ib(17,"span"),s.lc(18,"Adding custom metadata"),s.Hb(),s.Hb(),s.Ib(19,"p"),s.lc(20,"To attach custom metadata for a field, use the "),s.Ib(21,"code"),s.lc(22,"@Extensions()"),s.Hb(),s.lc(23," decorator exported from the "),s.Ib(24,"code"),s.lc(25,"@nestjs/graphql"),s.Hb(),s.lc(26," package."),s.Hb(),s.Ib(27,"pre"),s.Ib(28,"code",8),s.lc(29,"\n@Field()\n@Extensions({ role: Role.ADMIN })\npassword: string;"),s.Hb(),s.Hb(),s.Ib(30,"p"),s.lc(31,"In the example above, we assigned the "),s.Ib(32,"code"),s.lc(33,"role"),s.Hb(),s.lc(34," metadata property the value of "),s.Ib(35,"code"),s.lc(36,"Role.ADMIN"),s.Hb(),s.lc(37,". "),s.Ib(38,"code"),s.lc(39,"Role"),s.Hb(),s.lc(40," is a simple TypeScript enum that groups all the user roles available in our system."),s.Hb(),s.Ib(41,"p"),s.lc(42,"Note, in addition to setting metadata on fields, you can use the "),s.Ib(43,"code"),s.lc(44,"@Extensions()"),s.Hb(),s.lc(45," decorator at the class level and method level (e.g., on the query handler)."),s.Hb(),s.Ib(46,"h4",9),s.Ib(47,"span"),s.lc(48,"Using custom metadata"),s.Hb(),s.Hb(),s.Ib(49,"p"),s.lc(50,"The logic that leverages the custom metatada can be as complex as needed. For example, you can create a simple interceptor that stores/logs events per method invocation, or create a sophisticated guard that "),s.Ib(51,"strong"),s.lc(52,"analyzes requested fields"),s.Hb(),s.lc(53,", iterates through the "),s.Ib(54,"code"),s.lc(55,"GraphQLObjectType"),s.Hb(),s.lc(56," definition, and matches the roles required to retrieve specific fields with the caller permissions (field-level permissions system)."),s.Hb(),s.Ib(57,"p"),s.lc(58,"Let's define a "),s.Ib(59,"code"),s.lc(60,"FieldRolesGuard"),s.Hb(),s.lc(61," that implements a basic version of such a field-level permissions system."),s.Hb(),s.Ib(62,"pre"),s.Ib(63,"code",8),s.lc(64,"\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { GqlExecutionContext } from '@nestjs/graphql';\nimport { GraphQLNonNull, GraphQLObjectType, GraphQLResolveInfo } from 'graphql';\nimport * as graphqlFields from 'graphql-fields';\n\n@Injectable()\nexport class FieldRolesGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const info = GqlExecutionContext.create(context).getInfo<\n      GraphQLResolveInfo\n    >();\n    const returnType = (info.returnType instanceof GraphQLNonNull\n      ? info.returnType.ofType\n      : info.returnType) as GraphQLObjectType;\n\n    const fields = returnType.getFields();\n    const requestedFields = graphqlFields(info);\n\n    Object.entries(fields)\n      .filter(([key]) => key in requestedFields)\n      .map(([_, field]) => field)\n      .filter((field) => field.extensions && field.extensions.role)\n      .forEach((field) => {\n        // match user and field roles here\n        console.log(field.extensions.role);\n      });\n\n    return true;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(65,"blockquote",6),s.Ib(66,"strong"),s.lc(67,"Warning"),s.Hb(),s.lc(68," For illustration purposes, we assumed that "),s.Ib(69,"strong"),s.lc(70,"every"),s.Hb(),s.lc(71," resolver returns either the "),s.Ib(72,"code"),s.lc(73,"GraphQLObjectType"),s.Hb(),s.lc(74," or "),s.Ib(75,"code"),s.lc(76,"GraphQLNonNull"),s.Hb(),s.lc(77," that wraps the object type. In a real-world application, you should cover other cases (scalars, etc.). Note that using this particular implementation can lead to unexpected errors (e.g., missing "),s.Ib(78,"code"),s.lc(79,"getFields()"),s.Hb(),s.lc(80," method).\n"),s.Hb(),s.Ib(81,"p"),s.lc(82,"In the example above, we've used the "),s.Ib(83,"a",10),s.lc(84,"graphql-fields"),s.Hb(),s.lc(85," package that turns the "),s.Ib(86,"code"),s.lc(87,"GraphQLResolveInfo"),s.Hb(),s.lc(88," object into an object that consists of the requested fields. We used this specific library to make the presented example somewhat simpler."),s.Hb(),s.Ib(89,"p"),s.lc(90,"With this guard in place, if the return type of any resolver contains a field annotated with the "),s.Ib(91,"code"),s.lc(92),s.Hb(),s.lc(93," decorator, this "),s.Ib(94,"code"),s.lc(95,"role"),s.Hb(),s.lc(96," ("),s.Ib(97,"code"),s.lc(98,"Role.ADMIN"),s.Hb(),s.lc(99,") will be logged in the console "),s.Ib(100,"strong"),s.lc(101,"if requested"),s.Hb(),s.lc(102," in the GraphQL query."),s.Hb(),s.Hb()),2&e&&(s.vb(92),s.oc("@Extensions(","{"," role: Role.ADMIN ","}","})"))},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const y=s.Kb(f);let v=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return w(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-federation"]],features:[s.tb],decls:177,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/federation.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","federation"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/federation/introduction/"],["rel","nofollow","target","_blank","href","https://blog.apollographql.com/apollo-federation-f260cf525d21"],[1,"warning"],["appAnchor","","id","federated-example-users"],[1,"language-bash"],[1,"language-graphql"],[1,"language-typescript"],["appAnchor","","id","federated-example-posts"],["appAnchor","","id","federated-example-gateway"],[1,"info"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graph-manager/federation/"],["appAnchor","","id","sharing-context"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/api/apollo-gateway/#remotegraphqldatasource"],["appAnchor","","id","async-configuration"],["href","/graphql/quick-start#async-configuration"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Federation"),s.Hb(),s.Ib(7,"p"),s.Ib(8,"a",6),s.lc(9,"Apollo Federation"),s.Hb(),s.lc(10," offers a means of splitting your monolithic GraphQL server into independent microservices. It consists of two components: a gateway and one or more federated microservices. Each microservice holds part of the schema and the gateway merges the schemas into a single schema that can be consumed by the client."),s.Hb(),s.Ib(11,"p"),s.lc(12,"To quote the "),s.Ib(13,"a",7),s.lc(14,"Apollo docs"),s.Hb(),s.lc(15,", Federation is designed with these core principles:"),s.Hb(),s.Ib(16,"ul"),s.Ib(17,"li"),s.lc(18,"Building a graph should be "),s.Ib(19,"strong"),s.lc(20,"declarative."),s.Hb(),s.lc(21," With federation, you compose a graph declaratively from within your schema instead of writing imperative schema stitching code."),s.Hb(),s.Ib(22,"li"),s.lc(23,"Code should be separated by "),s.Ib(24,"strong"),s.lc(25,"concern"),s.Hb(),s.lc(26,", not by types. Often no single team controls every aspect of an important type like a User or Product, so the definition of these types should be distributed across teams and codebases, rather than centralized."),s.Hb(),s.Ib(27,"li"),s.lc(28,"The graph should be simple for clients to consume. Together, federated services can form a complete, product-focused graph that accurately reflects how it\u2019s being consumed on the client."),s.Hb(),s.Ib(29,"li"),s.lc(30,"It\u2019s just "),s.Ib(31,"strong"),s.lc(32,"GraphQL"),s.Hb(),s.lc(33,", using only spec-compliant features of the language. Any language, not just JavaScript, can implement federation."),s.Hb(),s.Hb(),s.Ib(34,"blockquote",8),s.Ib(35,"strong"),s.lc(36,"Warning"),s.Hb(),s.lc(37," Apollo Federation currently does not support subscriptions.\n"),s.Hb(),s.Ib(38,"p"),s.lc(39,"In the next example, we'll set up a demo application with a gateway and two federated endpoints: a Users service and a Posts service."),s.Hb(),s.Ib(40,"h4",9),s.Ib(41,"span"),s.lc(42,"Federated example: Users"),s.Hb(),s.Hb(),s.Ib(43,"p"),s.lc(44,"First install the optional dependency for federation:"),s.Hb(),s.Ib(45,"pre"),s.Ib(46,"code",10),s.lc(47,"\n$ npm install --save @apollo/federation"),s.Hb(),s.Hb(),s.Ib(48,"p"),s.lc(49,"The User service has a simple schema. Note the "),s.Ib(50,"code"),s.lc(51,"@key"),s.Hb(),s.lc(52," directive: it tells the Apollo query planner that a particular instance of User can be fetched if you have its "),s.Ib(53,"code"),s.lc(54,"id"),s.Hb(),s.lc(55,". Also note that we extend the "),s.Ib(56,"code"),s.lc(57,"Query"),s.Hb(),s.lc(58," type."),s.Hb(),s.Ib(59,"pre"),s.Ib(60,"code",11),s.lc(61,'\ntype User @key(fields: "id") {\n  id: ID!\n  name: String!\n}\n\nextend type Query {\n  getUser(id: ID!): User\n}'),s.Hb(),s.Hb(),s.Ib(62,"p"),s.lc(63,"Our resolver has one extra method: "),s.Ib(64,"code"),s.lc(65,"resolveReference"),s.Hb(),s.lc(66,". It's called by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later on. Please note the "),s.Ib(67,"code"),s.lc(68,"@ResolveReference"),s.Hb(),s.lc(69," decorator."),s.Hb(),s.Ib(70,"pre"),s.Ib(71,"code",12),s.lc(72,"\nimport { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';\nimport { UsersService } from './users.service';\n\n@Resolver('User')\nexport class UsersResolvers {\n  constructor(private usersService: UsersService) {}\n\n  @Query()\n  getUser(@Args('id') id: string) {\n    return this.usersService.findById(id);\n  }\n\n  @ResolveReference()\n  resolveReference(reference: { __typename: string; id: string }) {\n    return this.usersService.findById(reference.id);\n  }\n}"),s.Hb(),s.Hb(),s.Ib(73,"p"),s.lc(74,"Finally, we hook everything up in a module together with a "),s.Ib(75,"code"),s.lc(76,"GraphQLFederationModule"),s.Hb(),s.lc(77,". This module accepts the same options as the regular "),s.Ib(78,"code"),s.lc(79,"GraphQLModule"),s.Hb(),s.lc(80,"."),s.Hb(),s.Ib(81,"pre"),s.Ib(82,"code",12),s.lc(83,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLFederationModule } from '@nestjs/graphql';\nimport { UsersResolvers } from './users.resolvers';\n\n@Module({\n  imports: [\n    GraphQLFederationModule.forRoot({\n      typePaths: ['**/*.graphql'],\n    }),\n  ],\n  providers: [UsersResolvers],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(84,"h4",13),s.Ib(85,"span"),s.lc(86,"Federated example: Posts"),s.Hb(),s.Hb(),s.Ib(87,"p"),s.lc(88,"The Posts service references the User type in its schema by marking it with the "),s.Ib(89,"code"),s.lc(90,"extend"),s.Hb(),s.lc(91," keyword. It also adds one property to the User type. Note the "),s.Ib(92,"code"),s.lc(93,"@key"),s.Hb(),s.lc(94," directive used for matching instances of User, and the "),s.Ib(95,"code"),s.lc(96,"@external"),s.Hb(),s.lc(97," directive indicating that the "),s.Ib(98,"code"),s.lc(99,"id"),s.Hb(),s.lc(100," field is managed elsewhere."),s.Hb(),s.Ib(101,"pre"),s.Ib(102,"code",11),s.lc(103,'\ntype Post @key(fields: "id") {\n  id: ID!\n  title: String!\n  body: String!\n  user: User\n}\n\nextend type User @key(fields: "id") {\n  id: ID! @external\n  posts: [Post]\n}\n\nextend type Query {\n  getPosts: [Post]\n}'),s.Hb(),s.Hb(),s.Ib(104,"p"),s.lc(105,"Our resolver has one method of interest here: "),s.Ib(106,"code"),s.lc(107,"getUser"),s.Hb(),s.lc(108,". It returns a reference containing "),s.Ib(109,"code"),s.lc(110,"__typename"),s.Hb(),s.lc(111," and any additional properties your application needs to resolve the reference, in this case only an "),s.Ib(112,"code"),s.lc(113,"id"),s.Hb(),s.lc(114,". The "),s.Ib(115,"code"),s.lc(116,"__typename"),s.Hb(),s.lc(117," is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and request the instance. The Users service discussed above will be called on the "),s.Ib(118,"code"),s.lc(119,"resolveReference"),s.Hb(),s.lc(120," method."),s.Hb(),s.Ib(121,"pre"),s.Ib(122,"code",12),s.lc(123,"\nimport { Query, Resolver, Parent, ResolveProperty } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './posts.interfaces';\n\n@Resolver('Post')\nexport class PostsResolvers {\n  constructor(private postsService: PostsService) {}\n\n  @Query('getPosts')\n  getPosts() {\n    return this.postsService.findAll();\n  }\n\n  @ResolveProperty('user')\n  getUser(@Parent() post: Post) {\n    return { __typename: 'User', id: post.userId };\n  }\n}"),s.Hb(),s.Hb(),s.Ib(124,"p"),s.lc(125,"The Posts service has virtually the same module, but is included below for the sake of completeness:"),s.Hb(),s.Ib(126,"pre"),s.Ib(127,"code",12),s.lc(128,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLFederationModule } from '@nestjs/graphql';\nimport { PostsResolvers } from './posts.resolvers';\n\n@Module({\n  imports: [\n    GraphQLFederationModule.forRoot({\n      typePaths: ['**/*.graphql'],\n    }),\n  ],\n  providers: [PostsResolvers],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(129,"h4",14),s.Ib(130,"span"),s.lc(131,"Federated example: Gateway"),s.Hb(),s.Hb(),s.Ib(132,"p"),s.lc(133,"First install the optional dependency for the gateway: "),s.Ib(134,"code"),s.lc(135,"npm install --save @apollo/gateway"),s.Hb(),s.lc(136,"."),s.Hb(),s.Ib(137,"p"),s.lc(138,"Our gateway only needs a list of endpoints and will auto-discover the schemas from there. The code for our gateway is therefore very short:"),s.Hb(),s.Ib(139,"pre"),s.Ib(140,"code",12),s.lc(141,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLGatewayModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLGatewayModule.forRoot({\n      server: {\n        // ... Apollo server options\n        cors: true,\n      },\n      gateway: {\n        serviceList: [\n          { name: 'users', url: 'http://user-service/graphql' },\n          { name: 'posts', url: 'http://post-service/graphql' },\n        ],\n      },\n    }),\n  ],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(142,"blockquote",15),s.Ib(143,"strong"),s.lc(144,"Hint"),s.Hb(),s.lc(145," Apollo recommends that you don't rely on the service discovery in a production environment but use their "),s.Ib(146,"a",16),s.lc(147,"Graph Manager"),s.Hb(),s.lc(148," instead.\n"),s.Hb(),s.Ib(149,"h4",17),s.Ib(150,"span"),s.lc(151,"Sharing context"),s.Hb(),s.Hb(),s.Ib(152,"p"),s.lc(153,"You can customize the requests between the gateway and federated services using a build service. This allows you to share context about the request. You can easily extend the default "),s.Ib(154,"code"),s.lc(155,"RemoteGraphQLDataSource"),s.Hb(),s.lc(156," and implement one of the hooks. Please refer to "),s.Ib(157,"a",18),s.lc(158,"Apollo Docs"),s.Hb(),s.lc(159," on "),s.Ib(160,"code"),s.lc(161,"RemoteGraphQLDataSource"),s.Hb(),s.lc(162," for more information about the possibilities."),s.Hb(),s.Ib(163,"pre"),s.Ib(164,"code",12),s.lc(165,"\nimport { Module } from '@nestjs/common';\nimport { GATEWAY_BUILD_SERVICE, GraphQLGatewayModule } from '@nestjs/graphql';\nimport { RemoteGraphQLDataSource } from '@apollo/gateway';\nimport { decode } from 'jsonwebtoken';\n\nclass AuthenticatedDataSource extends RemoteGraphQLDataSource {\n  async willSendRequest({ request, context }) {\n    const { userId } = await decode(context.jwt);\n    request.http.headers.set('x-user-id', userId);\n  }\n}\n\n@Module({\n  providers: [\n    {\n      provide: AuthenticatedDataSource,\n      useValue: AuthenticatedDataSource,\n    },\n    {\n      provide: GATEWAY_BUILD_SERVICE,\n      useFactory: AuthenticatedDataSource => {\n        return ({ name, url }) => new AuthenticatedDataSource({ url });\n      },\n      inject: [AuthenticatedDataSource],\n    },\n  ],\n  exports: [GATEWAY_BUILD_SERVICE],\n})\nclass BuildServiceModule {}\n\n@Module({\n  imports: [\n    GraphQLGatewayModule.forRootAsync({\n      useFactory: async () => ({\n        gateway: {\n          serviceList: [\n            /* services */\n          ],\n        },\n        server: {\n          context: ({ req }) => ({\n            jwt: req.headers.authorization,\n          }),\n        },\n      }),\n      imports: [BuildServiceModule],\n      inject: [GATEWAY_BUILD_SERVICE],\n    }),\n  ],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(166,"h4",19),s.Ib(167,"span"),s.lc(168,"Async configuration"),s.Hb(),s.Hb(),s.Ib(169,"p"),s.lc(170,"Both the Federation and Gateway modules support asynchronous initialization using the same "),s.Ib(171,"code"),s.lc(172,"forRootAsync"),s.Hb(),s.lc(173," that's documented in "),s.Ib(174,"a",20),s.lc(175,"Quick start"),s.Hb(),s.lc(176,"."),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const w=s.Kb(v);let A=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return x(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-guards-interceptors"]],features:[s.tb],decls:209,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/guards-interceptors.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","other-features"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/directives/"],["routerLink","/guards"],["routerLink","/interceptors"],["appAnchor","","id","overview"],["routerLink","/exception-filters"],["routerLink","/pipes"],["routerLink","/custom-decorators"],[1,"language-typescript"],["appAnchor","","id","execution-context"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/execution-context"],["appAnchor","","id","exception-filters"],[1,"info"],["appAnchor","","id","custom-decorators"],["appAnchor","","id","execute-enhancers-at-the-field-resolver-level"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/graphql/issues/320#issuecomment-511193229"],[1,""]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Other features"),s.Hb(),s.Ib(7,"p"),s.lc(8,"In the GraphQL world, there is a lot of debate about handling issues like "),s.Ib(9,"strong"),s.lc(10,"authentication"),s.Hb(),s.lc(11,", or "),s.Ib(12,"strong"),s.lc(13,"side-effects"),s.Hb(),s.lc(14," of operations. Should we handle things inside the business logic? Should we use a higher-order function to enhance queries and mutations with authorization logic? Or should we use "),s.Ib(15,"a",6),s.lc(16,"schema directives"),s.Hb(),s.lc(17,"? There is no single one-size-fits-all answer to these questions."),s.Hb(),s.Ib(18,"p"),s.lc(19,"Nest helps address these issues with its cross-platform features like "),s.Ib(20,"a",7),s.lc(21,"guards"),s.Hb(),s.lc(22," and "),s.Ib(23,"a",8),s.lc(24,"interceptors"),s.Hb(),s.lc(25,". The philosophy is to reduce redundancy and provide tooling that helps create well-structured, readable, and consistent applications."),s.Hb(),s.Ib(26,"h4",9),s.Ib(27,"span"),s.lc(28,"Overview"),s.Hb(),s.Hb(),s.Ib(29,"p"),s.lc(30,"You can use standard "),s.Ib(31,"a",7),s.lc(32,"guards"),s.Hb(),s.lc(33,", "),s.Ib(34,"a",8),s.lc(35,"interceptors"),s.Hb(),s.lc(36,", "),s.Ib(37,"a",10),s.lc(38,"filters"),s.Hb(),s.lc(39," and "),s.Ib(40,"a",11),s.lc(41,"pipes"),s.Hb(),s.lc(42," in the same fashion with GraphQL as with any RESTful application. Additionally, you can easily create your own decorators by leveraging the "),s.Ib(43,"a",12),s.lc(44,"custom decorators"),s.Hb(),s.lc(45," feature. Let's take a look at a sample GraphQL query handler."),s.Hb(),s.Ib(46,"pre"),s.Ib(47,"code",13),s.lc(48,"\n@Query('author')\n@UseGuards(AuthGuard)\nasync getAuthor(@Args('id', ParseIntPipe) id: number) {\n  return this.authorsService.findOneById(id);\n}"),s.Hb(),s.Hb(),s.Ib(49,"p"),s.lc(50,"As you can see, GraphQL works with both guards and pipes in the same way as HTTP REST handlers. Because of this, you can move your authentication logic to a guard; you can even reuse the same guard class across both a REST and GraphQL API interface. Similarly, interceptors work across both types of applications in the same way:"),s.Hb(),s.Ib(51,"pre"),s.Ib(52,"code",13),s.lc(53,"\n@Mutation()\n@UseInterceptors(EventsInterceptor)\nasync upvotePost(@Args('postId') postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}"),s.Hb(),s.Hb(),s.Ib(54,"h4",14),s.Ib(55,"span"),s.lc(56,"Execution context"),s.Hb(),s.Hb(),s.Ib(57,"p"),s.lc(58,"Since GraphQL receives a different type of data in the incoming request, the "),s.Ib(59,"a",15),s.lc(60,"execution context"),s.Hb(),s.lc(61," received by both guards and interceptors is somewhat different with GraphQL vs. REST. GraphQL resolvers have a distinct set of arguments: "),s.Ib(62,"code"),s.lc(63,"root"),s.Hb(),s.lc(64,", "),s.Ib(65,"code"),s.lc(66,"args"),s.Hb(),s.lc(67,", "),s.Ib(68,"code"),s.lc(69,"context"),s.Hb(),s.lc(70,", and "),s.Ib(71,"code"),s.lc(72,"info"),s.Hb(),s.lc(73,". Thus guards and interceptors must transform the generic "),s.Ib(74,"code"),s.lc(75,"ExecutionContext"),s.Hb(),s.lc(76," to a "),s.Ib(77,"code"),s.lc(78,"GqlExecutionContext"),s.Hb(),s.lc(79,". This is straightforward:"),s.Hb(),s.Ib(80,"pre"),s.Ib(81,"code",13),s.lc(82,"\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { GqlExecutionContext } from '@nestjs/graphql';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const ctx = GqlExecutionContext.create(context);\n    return true;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(83,"p"),s.lc(84,"The GraphQL context object returned by "),s.Ib(85,"code"),s.lc(86,"GqlExecutionContext.create()"),s.Hb(),s.lc(87," exposes a "),s.Ib(88,"strong"),s.lc(89,"get"),s.Hb(),s.lc(90," method for each GraphQL resolver argument (e.g., "),s.Ib(91,"code"),s.lc(92,"getArgs()"),s.Hb(),s.lc(93,", "),s.Ib(94,"code"),s.lc(95,"getContext()"),s.Hb(),s.lc(96,", etc). Once transformed, we can easily pick out any GraphQL argument for the current request."),s.Hb(),s.Ib(97,"h4",16),s.Ib(98,"span"),s.lc(99,"Exception filters"),s.Hb(),s.Hb(),s.Ib(100,"p"),s.lc(101,"Nest standard "),s.Ib(102,"a",10),s.lc(103,"exception filters"),s.Hb(),s.lc(104," are compatible with GraphQL applications as well. As with "),s.Ib(105,"code"),s.lc(106,"ExecutionContext"),s.Hb(),s.lc(107,", GraphQL apps should transform the "),s.Ib(108,"code"),s.lc(109,"ArgumentsHost"),s.Hb(),s.lc(110," object to a "),s.Ib(111,"code"),s.lc(112,"GqlArgumentsHost"),s.Hb(),s.lc(113," object."),s.Hb(),s.Ib(114,"pre"),s.Ib(115,"code",13),s.lc(116,"\n@Catch(HttpException)\nexport class HttpExceptionFilter implements GqlExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const gqlHost = GqlArgumentsHost.create(host);\n    return exception;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(117,"blockquote",17),s.Ib(118,"strong"),s.lc(119,"Hint"),s.Hb(),s.lc(120," Both "),s.Ib(121,"code"),s.lc(122,"GqlExceptionFilter"),s.Hb(),s.lc(123," and "),s.Ib(124,"code"),s.lc(125,"GqlArgumentsHost"),s.Hb(),s.lc(126," are imported from the "),s.Ib(127,"code"),s.lc(128,"@nestjs/graphql"),s.Hb(),s.lc(129," package.\n"),s.Hb(),s.Ib(130,"p"),s.lc(131,"Note that unlike the REST case, you don't use the native "),s.Ib(132,"code"),s.lc(133,"response"),s.Hb(),s.lc(134," object to generate a response."),s.Hb(),s.Ib(135,"h4",18),s.Ib(136,"span"),s.lc(137,"Custom decorators"),s.Hb(),s.Hb(),s.Ib(138,"p"),s.lc(139,"As mentioned, the "),s.Ib(140,"a",12),s.lc(141,"custom decorators"),s.Hb(),s.lc(142," feature works as expected with GraphQL resolvers."),s.Hb(),s.Ib(143,"pre"),s.Ib(144,"code",13),s.lc(145,"\nexport const User = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) =>\n    GqlExecutionContext.create(ctx).getContext().user,\n);"),s.Hb(),s.Hb(),s.Ib(146,"p"),s.lc(147,"Use the "),s.Ib(148,"code"),s.lc(149,"@User()"),s.Hb(),s.lc(150," custom decorator as follows:"),s.Hb(),s.Ib(151,"pre"),s.Ib(152,"code",13),s.lc(153,"\n@Mutation()\nasync upvotePost(\n  @User() user: UserEntity,\n  @Args('postId') postId: number,\n) {}"),s.Hb(),s.Hb(),s.Ib(154,"blockquote",17),s.Ib(155,"strong"),s.lc(156,"Hint"),s.Hb(),s.lc(157," In the above example, we have assumed that the "),s.Ib(158,"code"),s.lc(159,"user"),s.Hb(),s.lc(160," object is assigned to the context of your GraphQL application.\n"),s.Hb(),s.Ib(161,"h4",19),s.Ib(162,"span"),s.lc(163,"Execute enhancers at the field resolver level"),s.Hb(),s.Hb(),s.Ib(164,"p"),s.lc(165,"In the GraphQL context, Nest does not run "),s.Ib(166,"strong"),s.lc(167,"enhancers"),s.Hb(),s.lc(168," (the generic name for interceptors, guards and filters) at the field level "),s.Ib(169,"a",20),s.lc(170,"see this issue"),s.Hb(),s.lc(171,": they only run for the top level "),s.Ib(172,"code"),s.lc(173,"@Query()"),s.Hb(),s.lc(174,"/"),s.Ib(175,"code"),s.lc(176,"@Mutation()"),s.Hb(),s.lc(177," method. You can tell Nest to execute interceptors, guards or filters for methods annotated with "),s.Ib(178,"code"),s.lc(179,"@ResolveField()"),s.Hb(),s.lc(180," by setting the "),s.Ib(181,"code"),s.lc(182,"fieldResolverEnhancers"),s.Hb(),s.lc(183," option in "),s.Ib(184,"code"),s.lc(185,"GqlModuleOptions"),s.Hb(),s.lc(186,". Pass it a list of "),s.Ib(187,"code"),s.lc(188,"'interceptors'"),s.Hb(),s.lc(189,", "),s.Ib(190,"code"),s.lc(191,"'guards'"),s.Hb(),s.lc(192,", and/or "),s.Ib(193,"code"),s.lc(194,"'filters'"),s.Hb(),s.lc(195," as appropriate:"),s.Hb(),s.Ib(196,"pre"),s.Ib(197,"code",13),s.lc(198,"\nGraphQLModule.forRoot({\n  fieldResolverEnhancers: ['interceptors']\n}),"),s.Hb(),s.Hb(),s.Ib(199,"blockquote",21),s.Ib(200,"strong"),s.lc(201,"Warning"),s.Hb(),s.lc(202," Enabling enhancers for field resolvers can cause performance issues when you are returning lots of records and your field resolver is executed thousands of times. For this reason, when you enable "),s.Ib(203,"code"),s.lc(204,"fieldResolverEnhancers"),s.Hb(),s.lc(205,", we advise you to skip execution of enhancers that are not strictly necessary for your field resolvers. You can do this using the following helper function:\n"),s.Hb(),s.Ib(206,"pre"),s.Ib(207,"code",13),s.lc(208,"\nexport function isResolvingGraphQLField(context: ExecutionContext): boolean {\n  if (context.getType<GqlContextType>() === 'graphql') {\n    const gqlContext = GqlExecutionContext.create(context);\n    const info = gqlContext.getInfo();\n    const parentType = info.parentType.name;\n    return parentType !== 'Query' && parentType !== 'Mutation';\n  }\n  return false;\n}"),s.Hb(),s.Hb(),s.Hb())},directives:[a.f,l.a],encapsulation:2,changeDetection:0}),e})();const x=s.Kb(A);let T=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return S(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-interfaces"]],features:[s.tb],decls:115,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/interfaces.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","interfaces"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#interfaces"],["appAnchor","","id","code-first"],[1,"language-typescript"],[1,"warning"],[1,"language-graphql"],[1,"info"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Interfaces"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Like many type systems, GraphQL supports interfaces. An "),s.Ib(9,"strong"),s.lc(10,"Interface"),s.Hb(),s.lc(11," is an abstract type that includes a certain set of fields that a type must include to implement the interface (read more "),s.Ib(12,"a",6),s.lc(13,"here"),s.Hb(),s.lc(14,")."),s.Hb(),s.Ib(15,"h4",7),s.Ib(16,"span"),s.lc(17,"Code first"),s.Hb(),s.Hb(),s.Ib(18,"p"),s.lc(19,"When using the code first approach, you define a GraphQL interface by creating an abstract class annotated with the "),s.Ib(20,"code"),s.lc(21,"@InterfaceType()"),s.Hb(),s.lc(22," decorator exported from the "),s.Ib(23,"code"),s.lc(24,"@nestjs/graphql"),s.Hb(),s.lc(25,"."),s.Hb(),s.Ib(26,"pre"),s.Ib(27,"code",8),s.lc(28,"\nimport { Field, ID, InterfaceType } from '@nestjs/graphql';\n\n@InterfaceType()\nexport abstract class Character {\n  @Field(type => ID)\n  id: string;\n\n  @Field()\n  name: string;\n}"),s.Hb(),s.Hb(),s.Ib(29,"blockquote",9),s.Ib(30,"strong"),s.lc(31,"Warning"),s.Hb(),s.lc(32," TypeScript interfaces cannot be used to define GraphQL interfaces.\n"),s.Hb(),s.Ib(33,"p"),s.lc(34,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(35,"pre"),s.Ib(36,"code",10),s.lc(37,"\ninterface Character {\n  id: ID!\n  name: String!\n}"),s.Hb(),s.Hb(),s.Ib(38,"p"),s.lc(39,"Now, to implement the "),s.Ib(40,"code"),s.lc(41,"Character"),s.Hb(),s.lc(42," interface, use the "),s.Ib(43,"code"),s.lc(44,"implements"),s.Hb(),s.lc(45," key:"),s.Hb(),s.Ib(46,"pre"),s.Ib(47,"code",8),s.lc(48,"\n@ObjectType({\n  implements: [Character],\n})\nexport class Human implements Character {\n  id: string;\n  name: string;\n}"),s.Hb(),s.Hb(),s.Ib(49,"blockquote",11),s.Ib(50,"strong"),s.lc(51,"Hint"),s.Hb(),s.lc(52," The "),s.Ib(53,"code"),s.lc(54,"@ObjectType()"),s.Hb(),s.lc(55," decorator is exported from the "),s.Ib(56,"code"),s.lc(57,"@nestjs/graphql"),s.Hb(),s.lc(58," package.\n"),s.Hb(),s.Ib(59,"p"),s.lc(60,"The default "),s.Ib(61,"code"),s.lc(62,"resolveType()"),s.Hb(),s.lc(63," function generated by the library extracts the type based on the value returned from the resolver method. This means that you must return class instances (you cannot return literal JavaScript objects)."),s.Hb(),s.Ib(64,"p"),s.lc(65,"To provide a customized "),s.Ib(66,"code"),s.lc(67,"resolveType()"),s.Hb(),s.lc(68," function, pass the "),s.Ib(69,"code"),s.lc(70,"resolveType"),s.Hb(),s.lc(71," property to the options object passed into the "),s.Ib(72,"code"),s.lc(73,"@InterfaceType()"),s.Hb(),s.lc(74," decorator, as follows:"),s.Hb(),s.Ib(75,"pre"),s.Ib(76,"code",8),s.lc(77,"\n@InterfaceType({\n  resolveType(book) {\n    if (book.colors) {\n      return ColoringBook;\n    }\n    return TextBook;\n  },\n})\nexport abstract class Book {\n  @Field(type => ID)\n  id: string;\n\n  @Field()\n  title: string;\n}"),s.Hb(),s.Hb(),s.Ib(78,"h4",12),s.Ib(79,"span"),s.lc(80,"Schema first"),s.Hb(),s.Hb(),s.Ib(81,"p"),s.lc(82,"To define an interface in the schema first approach, simply create a GraphQL interface with SDL."),s.Hb(),s.Ib(83,"pre"),s.Ib(84,"code",10),s.lc(85,"\ninterface Character {\n  id: ID!\n  name: String!\n}"),s.Hb(),s.Hb(),s.Ib(86,"p"),s.lc(87,"Then, you can use the typings generation feature (as shown in the "),s.Ib(88,"a",13),s.lc(89,"quick start"),s.Hb(),s.lc(90," chapter) to generate corresponding TypeScript definitions:"),s.Hb(),s.Ib(91,"pre"),s.Ib(92,"code",8),s.lc(93,"\nexport interface Character {\n  id: string;\n  name: string;\n}"),s.Hb(),s.Hb(),s.Ib(94,"p"),s.lc(95,"Interfaces require an extra "),s.Ib(96,"code"),s.lc(97,"__resolveType"),s.Hb(),s.lc(98," field in the resolver map to determine which type the interface should resolve to. Let's create a "),s.Ib(99,"code"),s.lc(100,"CharactersResolver"),s.Hb(),s.lc(101," class and define the "),s.Ib(102,"code"),s.lc(103,"__resolveType"),s.Hb(),s.lc(104," method:"),s.Hb(),s.Ib(105,"pre"),s.Ib(106,"code",8),s.lc(107,"\n@Resolver('Character')\nexport class CharactersResolver {\n  @ResolveField()\n  __resolveType(value) {\n    if ('age' in value) {\n      return Person;\n    }\n    return null;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(108,"blockquote",11),s.Ib(109,"strong"),s.lc(110,"Hint"),s.Hb(),s.lc(111," All decorators are exported from the "),s.Ib(112,"code"),s.lc(113,"@nestjs/graphql"),s.Hb(),s.lc(114," package.\n"),s.Hb(),s.Hb())},encapsulation:2,changeDetection:0}),e})();const S=s.Kb(T);let q=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return k(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-mapped-types"]],features:[s.tb],decls:202,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/mapped-types.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","mapped-types"],[1,"warning"],["appAnchor","","id","partial"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","pick"],["appAnchor","","id","omit"],["appAnchor","","id","intersection"],["appAnchor","","id","composition"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Mapped types"),s.Hb(),s.Ib(7,"blockquote",6),s.Ib(8,"strong"),s.lc(9,"Warning"),s.Hb(),s.lc(10," This chapter applies only to the code first approach.\n"),s.Hb(),s.Ib(11,"p"),s.lc(12,"As you build out features like CRUD (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient."),s.Hb(),s.Ib(13,"h4",7),s.Ib(14,"span"),s.lc(15,"Partial"),s.Hb(),s.Hb(),s.Ib(16,"p"),s.lc(17,"When building input validation types (also called DTOs), it's often useful to build "),s.Ib(18,"strong"),s.lc(19,"create"),s.Hb(),s.lc(20," and "),s.Ib(21,"strong"),s.lc(22,"update"),s.Hb(),s.lc(23," variations on the same type. For example, the "),s.Ib(24,"strong"),s.lc(25,"create"),s.Hb(),s.lc(26," variant may require all fields, while the "),s.Ib(27,"strong"),s.lc(28,"update"),s.Hb(),s.lc(29," variant may make all fields optional."),s.Hb(),s.Ib(30,"p"),s.lc(31,"Nest provides the "),s.Ib(32,"code"),s.lc(33,"PartialType()"),s.Hb(),s.lc(34," utility function to make this task easier and minimize boilerplate."),s.Hb(),s.Ib(35,"p"),s.lc(36,"The "),s.Ib(37,"code"),s.lc(38,"PartialType()"),s.Hb(),s.lc(39," function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a "),s.Ib(40,"strong"),s.lc(41,"create"),s.Hb(),s.lc(42," type as follows:"),s.Hb(),s.Ib(43,"pre"),s.Ib(44,"code",8),s.lc(45,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}"),s.Hb(),s.Hb(),s.Ib(46,"p"),s.lc(47,"By default, all of these fields are required. To create a type with the same fields, but with each one optional, use "),s.Ib(48,"code"),s.lc(49,"PartialType()"),s.Hb(),s.lc(50," passing the class reference ("),s.Ib(51,"code"),s.lc(52,"CreateUserInput"),s.Hb(),s.lc(53,") as an argument:"),s.Hb(),s.Ib(54,"pre"),s.Ib(55,"code",8),s.lc(56,"\n@InputType()\nexport class UpdateUserInput extends PartialType(CreateUserInput) {}"),s.Hb(),s.Hb(),s.Ib(57,"blockquote",9),s.Ib(58,"strong"),s.lc(59,"Hint"),s.Hb(),s.lc(60," The "),s.Ib(61,"code"),s.lc(62,"PartialType()"),s.Hb(),s.lc(63," function is imported from the "),s.Ib(64,"code"),s.lc(65,"@nestjs/graphql"),s.Hb(),s.lc(66," package.\n"),s.Hb(),s.Ib(67,"p"),s.lc(68,"The "),s.Ib(69,"code"),s.lc(70,"PartialType()"),s.Hb(),s.lc(71," function takes an optional second argument that is a reference to a decorator factory. This argument can be used to change the decorator function applied to the resulting (child) class. If not specified, the child class effectively uses the same decorator as the "),s.Ib(72,"strong"),s.lc(73,"parent"),s.Hb(),s.lc(74," class (the class referenced in the first argument). In the example above, we are extending "),s.Ib(75,"code"),s.lc(76,"CreateUserInput"),s.Hb(),s.lc(77," which is annotated with the "),s.Ib(78,"code"),s.lc(79,"@InputType()"),s.Hb(),s.lc(80," decorator. Since we want "),s.Ib(81,"code"),s.lc(82,"UpdateUserInput"),s.Hb(),s.lc(83," to also be treated as if it were decorated with "),s.Ib(84,"code"),s.lc(85,"@InputType()"),s.Hb(),s.lc(86,", we didn't need to pass "),s.Ib(87,"code"),s.lc(88,"InputType"),s.Hb(),s.lc(89," as the second argument. If the parent and child types are different, (e.g., the parent is decorated with "),s.Ib(90,"code"),s.lc(91,"@ObjectType"),s.Hb(),s.lc(92,"), we would pass "),s.Ib(93,"code"),s.lc(94,"InputType"),s.Hb(),s.lc(95," as the second argument. For example:"),s.Hb(),s.Ib(96,"pre"),s.Ib(97,"code",8),s.lc(98,"\n@InputType()\nexport class UpdateUserInput extends PartialType(User, InputType) {}"),s.Hb(),s.Hb(),s.Ib(99,"h4",10),s.Ib(100,"span"),s.lc(101,"Pick"),s.Hb(),s.Hb(),s.Ib(102,"p"),s.lc(103,"The "),s.Ib(104,"code"),s.lc(105,"PickType()"),s.Hb(),s.lc(106," function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:"),s.Hb(),s.Ib(107,"pre"),s.Ib(108,"code",8),s.lc(109,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}"),s.Hb(),s.Hb(),s.Ib(110,"p"),s.lc(111,"We can pick a set of properties from this class using the "),s.Ib(112,"code"),s.lc(113,"PickType()"),s.Hb(),s.lc(114," utility function:"),s.Hb(),s.Ib(115,"pre"),s.Ib(116,"code",8),s.lc(117,"\n@InputType()\nexport class UpdateEmailInput extends PickType(CreateUserInput, ['email'] as const) {}"),s.Hb(),s.Hb(),s.Ib(118,"blockquote",9),s.Ib(119,"strong"),s.lc(120,"Hint"),s.Hb(),s.lc(121," The "),s.Ib(122,"code"),s.lc(123,"PickType()"),s.Hb(),s.lc(124," function is imported from the "),s.Ib(125,"code"),s.lc(126,"@nestjs/graphql"),s.Hb(),s.lc(127," package.\n"),s.Hb(),s.Ib(128,"h4",11),s.Ib(129,"span"),s.lc(130,"Omit"),s.Hb(),s.Hb(),s.Ib(131,"p"),s.lc(132,"The "),s.Ib(133,"code"),s.lc(134,"OmitType()"),s.Hb(),s.lc(135," function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:"),s.Hb(),s.Ib(136,"pre"),s.Ib(137,"code",8),s.lc(138,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}"),s.Hb(),s.Hb(),s.Ib(139,"p"),s.lc(140,"We can generate a derived type that has every property "),s.Ib(141,"strong"),s.lc(142,"except"),s.Hb(),s.Ib(143,"code"),s.lc(144,"email"),s.Hb(),s.lc(145," as shown below. In this construct, the second argument to "),s.Ib(146,"code"),s.lc(147,"OmitType"),s.Hb(),s.lc(148," is an array of property names."),s.Hb(),s.Ib(149,"pre"),s.Ib(150,"code",8),s.lc(151,"\n@InputType()\nexport class UpdateUserInput extends OmitType(CreateUserInput, ['email'] as const) {}"),s.Hb(),s.Hb(),s.Ib(152,"blockquote",9),s.Ib(153,"strong"),s.lc(154,"Hint"),s.Hb(),s.lc(155," The "),s.Ib(156,"code"),s.lc(157,"OmitType()"),s.Hb(),s.lc(158," function is imported from the "),s.Ib(159,"code"),s.lc(160,"@nestjs/graphql"),s.Hb(),s.lc(161," package.\n"),s.Hb(),s.Ib(162,"h4",12),s.Ib(163,"span"),s.lc(164,"Intersection"),s.Hb(),s.Hb(),s.Ib(165,"p"),s.lc(166,"The "),s.Ib(167,"code"),s.lc(168,"IntersectionType()"),s.Hb(),s.lc(169," function combines two types into one new type (class). For example, suppose we start with two types like:"),s.Hb(),s.Ib(170,"pre"),s.Ib(171,"code",8),s.lc(172,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n}\n\n@ObjectType()\nexport class AdditionalUserInfo {\n  @Field()\n  firstName: string;\n\n  @Field()\n  lastName: string;\n}"),s.Hb(),s.Hb(),s.Ib(173,"p"),s.lc(174,"We can generate a new type that combines all properties in both types."),s.Hb(),s.Ib(175,"pre"),s.Ib(176,"code",8),s.lc(177,"\n@InputType()\nexport class UpdateUserInput extends IntersectionType(CreateUserInput, AdditionalUserInfo) {}"),s.Hb(),s.Hb(),s.Ib(178,"blockquote",9),s.Ib(179,"strong"),s.lc(180,"Hint"),s.Hb(),s.lc(181," The "),s.Ib(182,"code"),s.lc(183,"IntersectionType()"),s.Hb(),s.lc(184," function is imported from the "),s.Ib(185,"code"),s.lc(186,"@nestjs/graphql"),s.Hb(),s.lc(187," package.\n"),s.Hb(),s.Ib(188,"h4",13),s.Ib(189,"span"),s.lc(190,"Composition"),s.Hb(),s.Hb(),s.Ib(191,"p"),s.lc(192,"The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the "),s.Ib(193,"code"),s.lc(194,"CreateUserInput"),s.Hb(),s.lc(195," type except for "),s.Ib(196,"code"),s.lc(197,"email"),s.Hb(),s.lc(198,", and those properties will be set to optional:"),s.Hb(),s.Ib(199,"pre"),s.Ib(200,"code",8),s.lc(201,"\n@InputType()\nexport class UpdateUserInput extends PartialType(\n  OmitType(CreateUserInput, ['email'] as const),\n) {}"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const k=s.Kb(q);let L=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return G(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-mutations"]],features:[s.tb],decls:145,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/mutations.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","mutations"],["rel","nofollow","target","_blank","href","http://graphql.org/learn/queries/#mutations"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-tools/generate-schema.html"],["appAnchor","","id","code-first"],["routerLink","/graphql/resolvers"],[1,"language-typescript"],[1,"info"],[1,"language-graphql"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#input-types"],["routerLink","/graphql/cli-plugin"],["appAnchor","","id","schema-first"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Mutations"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well. In REST, any request could end up causing side-effects on the server, but best practice suggests we should not modify data in GET requests. GraphQL is similar - technically any query could be implemented to cause a data write. However, like REST, it's recommended to observe the convention that any operations that cause writes should be sent explicitly via a mutation (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,")."),s.Hb(),s.Ib(12,"p"),s.lc(13,"The official "),s.Ib(14,"a",7),s.lc(15,"Apollo"),s.Hb(),s.lc(16," documentation uses an "),s.Ib(17,"code"),s.lc(18,"upvotePost()"),s.Hb(),s.lc(19," mutation example. This mutation implements a method to increase a post's "),s.Ib(20,"code"),s.lc(21,"votes"),s.Hb(),s.lc(22," property value. To create an equivalent mutation in Nest, we'll make use of the "),s.Ib(23,"code"),s.lc(24,"@Mutation()"),s.Hb(),s.lc(25," decorator."),s.Hb(),s.Ib(26,"h4",8),s.Ib(27,"span"),s.lc(28,"Code first"),s.Hb(),s.Hb(),s.Ib(29,"p"),s.lc(30,"Let's add another method to the "),s.Ib(31,"code"),s.lc(32,"AuthorResolver"),s.Hb(),s.lc(33," used in the previous section (see "),s.Ib(34,"a",9),s.lc(35,"resolvers"),s.Hb(),s.lc(36,")."),s.Hb(),s.Ib(37,"pre"),s.Ib(38,"code",10),s.lc(39,"\n@Mutation(returns => Post)\nasync upvotePost(@Args({ name: 'postId', type: () => Int }) postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}"),s.Hb(),s.Hb(),s.Ib(40,"blockquote",11),s.Ib(41,"strong"),s.lc(42,"Hint"),s.Hb(),s.lc(43," All decorators (e.g., "),s.Ib(44,"code"),s.lc(45,"@Resolver"),s.Hb(),s.lc(46,", "),s.Ib(47,"code"),s.lc(48,"@ResolveField"),s.Hb(),s.lc(49,", "),s.Ib(50,"code"),s.lc(51,"@Args"),s.Hb(),s.lc(52,", etc.) are exported from the "),s.Ib(53,"code"),s.lc(54,"@nestjs/graphql"),s.Hb(),s.lc(55," package.\n"),s.Hb(),s.Ib(56,"p"),s.lc(57,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(58,"pre"),s.Ib(59,"code",12),s.lc(60,"\ntype Mutation {\n  upvotePost(postId: Int!): Post\n}"),s.Hb(),s.Hb(),s.Ib(61,"p"),s.lc(62,"The "),s.Ib(63,"code"),s.lc(64,"upvotePost()"),s.Hb(),s.lc(65," method takes "),s.Ib(66,"code"),s.lc(67,"postId"),s.Hb(),s.lc(68," ("),s.Ib(69,"code"),s.lc(70,"Int"),s.Hb(),s.lc(71,") as an argument and returns an updated "),s.Ib(72,"code"),s.lc(73,"Post"),s.Hb(),s.lc(74," entity. For the reasons explained in the "),s.Ib(75,"a",9),s.lc(76,"resolvers"),s.Hb(),s.lc(77," section, we have to explicitly set the expected type."),s.Hb(),s.Ib(78,"p"),s.lc(79,"If the mutation needs to take an object as an argument, we can create an "),s.Ib(80,"strong"),s.lc(81,"input type"),s.Hb(),s.lc(82,". The input type is a special kind of object type that can be passed in as an argument (read more "),s.Ib(83,"a",13),s.lc(84,"here"),s.Hb(),s.lc(85,"). To declare an input type, use the "),s.Ib(86,"code"),s.lc(87,"@InputType()"),s.Hb(),s.lc(88," decorator."),s.Hb(),s.Ib(89,"pre"),s.Ib(90,"code",10),s.lc(91,"\nimport { InputType, Field } from '@nestjs/graphql';\n\n@InputType()\nexport class UpvotePostInput {\n  @Field()\n  postId: number;\n}"),s.Hb(),s.Hb(),s.Ib(92,"blockquote",11),s.Ib(93,"strong"),s.lc(94,"Hint"),s.Hb(),s.lc(95," The "),s.Ib(96,"code"),s.lc(97,"@InputType()"),s.Hb(),s.lc(98," decorator takes an options object as an argument, so you can, for example, specify the input type's description. Note that, due to TypeScript's metadata reflection system limitations, you must either use the "),s.Ib(99,"code"),s.lc(100,"@Field"),s.Hb(),s.lc(101," decorator to manually indicate a type, or use a "),s.Ib(102,"a",14),s.lc(103,"CLI plugin"),s.Hb(),s.lc(104,".\n"),s.Hb(),s.Ib(105,"p"),s.lc(106,"We can then use this type in the resolver class:"),s.Hb(),s.Ib(107,"pre"),s.Ib(108,"code",10),s.lc(109,"\n@Mutation(returns => Post)\nasync upvotePost(\n  @Args('upvotePostData') upvotePostData: UpvotePostInput,\n) {}"),s.Hb(),s.Hb(),s.Ib(110,"h4",15),s.Ib(111,"span"),s.lc(112,"Schema first"),s.Hb(),s.Hb(),s.Ib(113,"p"),s.lc(114,"Let's extend our "),s.Ib(115,"code"),s.lc(116,"AuthorResolver"),s.Hb(),s.lc(117," used in the previous section (see "),s.Ib(118,"a",9),s.lc(119,"resolvers"),s.Hb(),s.lc(120,")."),s.Hb(),s.Ib(121,"pre"),s.Ib(122,"code",10),s.lc(123,"\n@Mutation()\nasync upvotePost(@Args('postId') postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}"),s.Hb(),s.Hb(),s.Ib(124,"p"),s.lc(125,"Note that we assumed above that the business logic has been moved to the "),s.Ib(126,"code"),s.lc(127,"PostsService"),s.Hb(),s.lc(128," (querying the post and incrementing its "),s.Ib(129,"code"),s.lc(130,"votes"),s.Hb(),s.lc(131," property). The logic inside the "),s.Ib(132,"code"),s.lc(133,"PostsService"),s.Hb(),s.lc(134," class can be as simple or sophisticated as needed. The main point of this example is to show how resolvers can interact with other providers."),s.Hb(),s.Ib(135,"p"),s.lc(136,"The last step is to add our mutation to the existing types definition."),s.Hb(),s.Ib(137,"pre"),s.Ib(138,"code",12),s.lc(139,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Mutation {\n  upvotePost(postId: Int!): Post\n}"),s.Hb(),s.Hb(),s.Ib(140,"p"),s.lc(141,"The "),s.Ib(142,"code"),s.lc(143,"upvotePost(postId: Int!): Post"),s.Hb(),s.lc(144," mutation is now available to be called as part of our application's GraphQL API."),s.Hb(),s.Hb())},directives:[l.a,a.f],encapsulation:2,changeDetection:0}),e})();const G=s.Kb(L);let Q=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return R(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-plugins"]],features:[s.tb],decls:63,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/plugins.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","plugins"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/integrations/plugins/"],["appAnchor","","id","custom-plugins"],[1,"language-typescript"],["appAnchor","","id","using-external-plugins"],[1,"info"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Plugins"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Plugins enable you to extend Apollo Server's core functionality by performing custom operations in response to certain events. Currently, these events correspond to individual phases of the GraphQL request lifecycle, and to the startup of Apollo Server itself (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,"). For example, a basic logging plugin might log the GraphQL query string associated with each request that's sent to Apollo Server."),s.Hb(),s.Ib(12,"h4",7),s.Ib(13,"span"),s.lc(14,"Custom plugins"),s.Hb(),s.Hb(),s.Ib(15,"p"),s.lc(16,"To create a plugin, declare a class annotated with the "),s.Ib(17,"code"),s.lc(18,"@Plugin"),s.Hb(),s.lc(19," decorator exported from the "),s.Ib(20,"code"),s.lc(21,"@nestjs/graphql"),s.Hb(),s.lc(22," package. Also, for better code autocompletion, implement the "),s.Ib(23,"code"),s.lc(24,"ApolloServerPlugin"),s.Hb(),s.lc(25," interface from the "),s.Ib(26,"code"),s.lc(27,"apollo-server-plugin-base"),s.Hb(),s.lc(28," package."),s.Hb(),s.Ib(29,"pre"),s.Ib(30,"code",8),s.lc(31,"\nimport { Plugin } from '@nestjs/graphql';\nimport {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n} from 'apollo-server-plugin-base';\n\n@Plugin()\nexport class LoggingPlugin implements ApolloServerPlugin {\n  requestDidStart(): GraphQLRequestListener {\n    console.log('Request started');\n    return {\n      willSendResponse() {\n        console.log('Will send response');\n      },\n    };\n  }\n}"),s.Hb(),s.Hb(),s.Ib(32,"p"),s.lc(33,"With this in place, we can register the "),s.Ib(34,"code"),s.lc(35,"LoggingPlugin"),s.Hb(),s.lc(36," as a provider."),s.Hb(),s.Ib(37,"pre"),s.Ib(38,"code",8),s.lc(39,"\n@Module({\n  providers: [LoggingPlugin],\n})\nexport class CommonModule {}"),s.Hb(),s.Hb(),s.Ib(40,"p"),s.lc(41,"Nest will automatically instantiate a plugin and apply it to the Apollo Server."),s.Hb(),s.Ib(42,"h4",9),s.Ib(43,"span"),s.lc(44,"Using external plugins"),s.Hb(),s.Hb(),s.Ib(45,"p"),s.lc(46,"There are several plugins provided out-of-the-box. To use an existing plugin, simply import it and add it to the "),s.Ib(47,"code"),s.lc(48,"plugins"),s.Hb(),s.lc(49," array:"),s.Hb(),s.Ib(50,"pre"),s.Ib(51,"code",8),s.lc(52,"\nGraphQLModule.forRoot({\n  // ...\n  plugins: [ApolloServerOperationRegistry({ /* options */})]\n}),"),s.Hb(),s.Hb(),s.Ib(53,"blockquote",10),s.Ib(54,"strong"),s.lc(55,"Hint"),s.Hb(),s.lc(56," The "),s.Ib(57,"code"),s.lc(58,"ApolloServerOperationRegistry"),s.Hb(),s.lc(59," plugin is exported from the "),s.Ib(60,"code"),s.lc(61,"apollo-server-plugin-operation-registry"),s.Hb(),s.lc(62," package.\n"),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const R=s.Kb(Q);var j=o("CquY");let F=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return P(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-quick-start"]],features:[s.tb],decls:406,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/quick-start.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","harnessing-the-power-of-typescript--graphql"],["rel","nofollow","target","_blank","href","https://graphql.org/"],["rel","nofollow","target","_blank","href","https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b"],["rel","nofollow","target","_blank","href","https://www.typescriptlang.org/"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/"],["appAnchor","","id","installation"],[1,"language-bash"],["appAnchor","","id","overview"],["appAnchor","","id","getting-started-with-graphql--typescript"],[1,"filename"],["app5a3c1ed9fbb1c32072614083485aafcf0ddcbdc1",""],[1,"language-typescript"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/v2/api/apollo-server.html#constructor-options-lt-ApolloServer-gt"],["appfc9f8f23d6fd441973c884fc03b436d18277c0be",""],["appAnchor","","id","graphql-playground"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/23-graphql-code-first"],["routerLink","/graphql/resolvers-map"],["src","/assets/playground.png","alt",""],["appAnchor","","id","multiple-endpoints"],["appAnchor","","id","code-first"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://en.wikipedia.org/wiki/Abstract_syntax_tree"],[1,"info"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/12-graphql-schema-first"],["appAnchor","","id","accessing-generated-schema"],["appAnchor","","id","async-configuration"],["href","https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h2",5),s.lc(6,"Harnessing the power of TypeScript & GraphQL"),s.Hb(),s.Ib(7,"p"),s.Ib(8,"a",6),s.lc(9,"GraphQL"),s.Hb(),s.lc(10," is a powerful query language for APIs and a runtime for fulfilling those queries with your existing data. It's an elegant approach that solves many problems typically found with REST APIs. For background, we suggest reading this "),s.Ib(11,"a",7),s.lc(12,"comparison"),s.Hb(),s.lc(13," between GraphQL and REST. GraphQL combined with "),s.Ib(14,"a",8),s.lc(15,"TypeScript"),s.Hb(),s.lc(16," helps you develop better type safety with your GraphQL queries, giving you end-to-end typing."),s.Hb(),s.Ib(17,"p"),s.lc(18,"In this chapter, we assume a basic understanding of GraphQL, and focus on how to work with the built-in "),s.Ib(19,"code"),s.lc(20,"@nestjs/graphql"),s.Hb(),s.lc(21," module. The "),s.Ib(22,"code"),s.lc(23,"GraphQLModule"),s.Hb(),s.lc(24," is a wrapper around the "),s.Ib(25,"a",9),s.lc(26,"Apollo"),s.Hb(),s.lc(27," server. We use this proven GraphQL package to provide a way to use GraphQL with Nest."),s.Hb(),s.Ib(28,"h4",10),s.Ib(29,"span"),s.lc(30,"Installation"),s.Hb(),s.Hb(),s.Ib(31,"p"),s.lc(32,"Start by installing the required packages:"),s.Hb(),s.Ib(33,"pre"),s.Ib(34,"code",11),s.lc(35,"\n$ npm i @nestjs/graphql graphql-tools graphql"),s.Hb(),s.Hb(),s.Ib(36,"p"),s.lc(37,"Depending on what underlying platform you use (Express or Fastify), you must also install either "),s.Ib(38,"code"),s.lc(39,"apollo-server-express"),s.Hb(),s.lc(40," or "),s.Ib(41,"code"),s.lc(42,"apollo-server-fastify"),s.Hb(),s.lc(43,"."),s.Hb(),s.Ib(44,"h4",12),s.Ib(45,"span"),s.lc(46,"Overview"),s.Hb(),s.Hb(),s.Ib(47,"p"),s.lc(48,"Nest offers two ways of building GraphQL applications, the "),s.Ib(49,"strong"),s.lc(50,"code first"),s.Hb(),s.lc(51," and the "),s.Ib(52,"strong"),s.lc(53,"schema first"),s.Hb(),s.lc(54," methods. You should choose the one that works best for you. Most of the chapters in this GraphQL section are divided into two main parts: one you should follow if you adopt "),s.Ib(55,"strong"),s.lc(56,"code first"),s.Hb(),s.lc(57,", and the other to be used if you adopt "),s.Ib(58,"strong"),s.lc(59,"schema first"),s.Hb(),s.lc(60,"."),s.Hb(),s.Ib(61,"p"),s.lc(62,"In the "),s.Ib(63,"strong"),s.lc(64,"code first"),s.Hb(),s.lc(65," approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema. This approach is useful if you prefer to work exclusively with TypeScript and avoid context switching between language syntaxes."),s.Hb(),s.Ib(66,"p"),s.lc(67,"In the "),s.Ib(68,"strong"),s.lc(69,"schema first"),s.Hb(),s.lc(70," approach, the source of truth is GraphQL SDL (Schema Definition Language) files. SDL is a language-agnostic way to share schema files between different platforms. Nest automatically generates your TypeScript definitions (using either classes or interfaces) based on the GraphQL schemas to reduce the need to write redundant boilerplate code."),s.Hb(),s.Ib(71,"h4",13),s.Ib(72,"span"),s.lc(73,"Getting started with GraphQL & TypeScript"),s.Hb(),s.Hb(),s.Ib(74,"p"),s.lc(75,"Once the packages are installed, we can import the "),s.Ib(76,"code"),s.lc(77,"GraphQLModule"),s.Hb(),s.lc(78," and configure it with the "),s.Ib(79,"code"),s.lc(80,"forRoot()"),s.Hb(),s.lc(81," static method."),s.Hb(),s.Ib(82,"span",14),s.Gb(83,"app-tabs",null,15),s.Hb(),s.Ib(85,"pre"),s.Ib(86,"code",16),s.lc(87,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({}),\n  ],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(88,"p"),s.lc(89,"The "),s.Ib(90,"code"),s.lc(91,"forRoot()"),s.Hb(),s.lc(92," method takes an options object as an argument. These options are passed through to the underlying Apollo instance (read more about available settings "),s.Ib(93,"a",17),s.lc(94,"here"),s.Hb(),s.lc(95,"). For example, if you want to disable the "),s.Ib(96,"code"),s.lc(97,"playground"),s.Hb(),s.lc(98," and turn off "),s.Ib(99,"code"),s.lc(100,"debug"),s.Hb(),s.lc(101," mode, pass the following options:"),s.Hb(),s.Ib(102,"span",14),s.Gb(103,"app-tabs",null,18),s.Hb(),s.Ib(105,"pre"),s.Ib(106,"code",16),s.lc(107,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      debug: false,\n      playground: false,\n    }),\n  ],\n})\nexport class AppModule {}"),s.Hb(),s.Hb(),s.Ib(108,"p"),s.lc(109,"As mentioned, these options will be forwarded to the "),s.Ib(110,"code"),s.lc(111,"ApolloServer"),s.Hb(),s.lc(112," constructor."),s.Hb(),s.Ib(113,"p"),s.Gb(114,"app-banner-enterprise"),s.Hb(),s.Ib(115,"h4",19),s.Ib(116,"span"),s.lc(117,"GraphQL playground"),s.Hb(),s.Hb(),s.Ib(118,"p"),s.lc(119,"The playground is a graphical, interactive, in-browser GraphQL IDE, available by default on the same URL as the GraphQL server itself. To access the playground, you need a basic GraphQL server configured and running. To see it now, you can install and build the "),s.Ib(120,"a",20),s.lc(121,"working example here"),s.Hb(),s.lc(122,". Alternatively, if you're following along with these code samples, once you've complete the steps in the "),s.Ib(123,"a",21),s.lc(124,"Resolvers chapter"),s.Hb(),s.lc(125,", you can access the playground."),s.Hb(),s.Ib(126,"p"),s.lc(127,"With that in place, and with your application running in the background, you can then open your web browser and navigate to "),s.Ib(128,"code"),s.lc(129,"http://localhost:3000/graphql"),s.Hb(),s.lc(130," (host and port may vary depending on your configuration). You will then see the GraphQL playground, as shown below."),s.Hb(),s.Ib(131,"figure"),s.Gb(132,"img",22),s.Hb(),s.Ib(133,"h4",23),s.Ib(134,"span"),s.lc(135,"Multiple endpoints"),s.Hb(),s.Hb(),s.Ib(136,"p"),s.lc(137,"Another useful feature of the "),s.Ib(138,"code"),s.lc(139,"@nestjs/graphql"),s.Hb(),s.lc(140," module is the ability to serve multiple endpoints at once. This lets you decide which modules should be included in which endpoint. By default, "),s.Ib(141,"code"),s.lc(142,"GraphQL"),s.Hb(),s.lc(143," searches for resolvers throughout the whole app. To limit this scan to only a subset of modules, use the "),s.Ib(144,"code"),s.lc(145,"include"),s.Hb(),s.lc(146," property."),s.Hb(),s.Ib(147,"pre"),s.Ib(148,"code",16),s.lc(149,"\nGraphQLModule.forRoot({\n  include: [CatsModule],\n}),"),s.Hb(),s.Hb(),s.Ib(150,"h4",24),s.Ib(151,"span"),s.lc(152,"Code first"),s.Hb(),s.Hb(),s.Ib(153,"p"),s.lc(154,"In the "),s.Ib(155,"strong"),s.lc(156,"code first"),s.Hb(),s.lc(157," approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema."),s.Hb(),s.Ib(158,"p"),s.lc(159,"To use the code first approach, start by adding the "),s.Ib(160,"code"),s.lc(161,"autoSchemaFile"),s.Hb(),s.lc(162," property to the options object:"),s.Hb(),s.Ib(163,"pre"),s.Ib(164,"code",16),s.lc(165,"\nGraphQLModule.forRoot({\n  autoSchemaFile: join(process.cwd(), 'src/schema.gql'),\n}),"),s.Hb(),s.Hb(),s.Ib(166,"p"),s.lc(167,"The "),s.Ib(168,"code"),s.lc(169,"autoSchemaFile"),s.Hb(),s.lc(170," property value is the path where your automatically generated schema will be created. Alternatively, the schema can be generated on-the-fly in memory. To enable this, set the "),s.Ib(171,"code"),s.lc(172,"autoSchemaFile"),s.Hb(),s.lc(173," property to "),s.Ib(174,"code"),s.lc(175,"true"),s.Hb(),s.lc(176,":"),s.Hb(),s.Ib(177,"pre"),s.Ib(178,"code",16),s.lc(179,"\nGraphQLModule.forRoot({\n  autoSchemaFile: true,\n}),"),s.Hb(),s.Hb(),s.Ib(180,"p"),s.lc(181,"By default, the types in the generated schema will be in the order they are defined in the included modules. To sort the schema lexicographically, set the "),s.Ib(182,"code"),s.lc(183,"sortSchema"),s.Hb(),s.lc(184," property to "),s.Ib(185,"code"),s.lc(186,"true"),s.Hb(),s.lc(187,":"),s.Hb(),s.Ib(188,"pre"),s.Ib(189,"code",16),s.lc(190,"\nGraphQLModule.forRoot({\n  autoSchemaFile: join(process.cwd(), 'src/schema.gql'),\n  sortSchema: true,\n}),"),s.Hb(),s.Hb(),s.Ib(191,"p"),s.lc(192,"A fully working code first sample is available "),s.Ib(193,"a",20),s.lc(194,"here"),s.Hb(),s.lc(195,"."),s.Hb(),s.Ib(196,"h4",25),s.Ib(197,"span"),s.lc(198,"Schema first"),s.Hb(),s.Hb(),s.Ib(199,"p"),s.lc(200,"To use the schema first approach, start by adding a "),s.Ib(201,"code"),s.lc(202,"typePaths"),s.Hb(),s.lc(203," property to the options object. The "),s.Ib(204,"code"),s.lc(205,"typePaths"),s.Hb(),s.lc(206," property indicates where the "),s.Ib(207,"code"),s.lc(208,"GraphQLModule"),s.Hb(),s.lc(209," should look for GraphQL SDL schema definition files you'll be writing. These files will be combined in memory; this allows you to split your schemas into several files and locate them near their resolvers."),s.Hb(),s.Ib(210,"pre"),s.Ib(211,"code",16),s.lc(212,"\nGraphQLModule.forRoot({\n  typePaths: ['./**/*.graphql'],\n}),"),s.Hb(),s.Hb(),s.Ib(213,"p"),s.lc(214,"You will typically also need to have TypeScript definitions (classes and interfaces) that correspond to the GraphQL SDL types. Creating the corresponding TypeScript definitions by hand is redundant and tedious. It leaves us without a single source of truth -- each change made within SDL forces us to adjust TypeScript definitions as well. To address this, the "),s.Ib(215,"code"),s.lc(216,"@nestjs/graphql"),s.Hb(),s.lc(217," package can "),s.Ib(218,"strong"),s.lc(219,"automatically generate"),s.Hb(),s.lc(220," TypeScript definitions from the abstract syntax tree ("),s.Ib(221,"a",26),s.lc(222,"AST"),s.Hb(),s.lc(223,"). To enable this feature, add the "),s.Ib(224,"code"),s.lc(225,"definitions"),s.Hb(),s.lc(226," options property when configuring the "),s.Ib(227,"code"),s.lc(228,"GraphQLModule"),s.Hb(),s.lc(229,"."),s.Hb(),s.Ib(230,"pre"),s.Ib(231,"code",16),s.lc(232,"\nGraphQLModule.forRoot({\n  typePaths: ['./**/*.graphql'],\n  definitions: {\n    path: join(process.cwd(), 'src/graphql.ts'),\n  },\n}),"),s.Hb(),s.Hb(),s.Ib(233,"p"),s.lc(234,"The path property of the "),s.Ib(235,"code"),s.lc(236,"definitions"),s.Hb(),s.lc(237," object indicates where to save generated TypeScript output. By default, all generated TypeScript types are created as interfaces. To generate classes instead, specify the "),s.Ib(238,"code"),s.lc(239,"outputAs"),s.Hb(),s.lc(240," property with a value of "),s.Ib(241,"code"),s.lc(242,"'class'"),s.Hb(),s.lc(243,"."),s.Hb(),s.Ib(244,"pre"),s.Ib(245,"code",16),s.lc(246,"\nGraphQLModule.forRoot({\n  typePaths: ['./**/*.graphql'],\n  definitions: {\n    path: join(process.cwd(), 'src/graphql.ts'),\n    outputAs: 'class',\n  },\n}),"),s.Hb(),s.Hb(),s.Ib(247,"p"),s.lc(248,"The above approach dynamically generates TypeScript definitions each time the application starts. Alternatively, it may be preferable to build a simple script to generate these on demand. For example, assume we create the following script as "),s.Ib(249,"code"),s.lc(250,"generate-typings.ts"),s.Hb(),s.lc(251,":"),s.Hb(),s.Ib(252,"pre"),s.Ib(253,"code",16),s.lc(254,"\nimport { GraphQLDefinitionsFactory } from '@nestjs/graphql';\nimport { join } from 'path';\n\nconst definitionsFactory = new GraphQLDefinitionsFactory();\ndefinitionsFactory.generate({\n  typePaths: ['./src/**/*.graphql'],\n  path: join(process.cwd(), 'src/graphql.ts'),\n  outputAs: 'class',\n});"),s.Hb(),s.Hb(),s.Ib(255,"p"),s.lc(256,"Now you can run this script on demand:"),s.Hb(),s.Ib(257,"pre"),s.Ib(258,"code",11),s.lc(259,"\n$ ts-node generate-typings"),s.Hb(),s.Hb(),s.Ib(260,"blockquote",27),s.Ib(261,"strong"),s.lc(262,"Hint"),s.Hb(),s.lc(263," You can compile the script beforehand (e.g., with "),s.Ib(264,"code"),s.lc(265,"tsc"),s.Hb(),s.lc(266,") and use "),s.Ib(267,"code"),s.lc(268,"node"),s.Hb(),s.lc(269," to execute it.\n"),s.Hb(),s.Ib(270,"p"),s.lc(271,"To enable watch mode for the script (to automatically generate typings whenever any "),s.Ib(272,"code"),s.lc(273,".graphql"),s.Hb(),s.lc(274," file changes), pass the "),s.Ib(275,"code"),s.lc(276,"watch"),s.Hb(),s.lc(277," option to the "),s.Ib(278,"code"),s.lc(279,"generate()"),s.Hb(),s.lc(280," method."),s.Hb(),s.Ib(281,"pre"),s.Ib(282,"code",16),s.lc(283,"\ndefinitionsFactory.generate({\n  typePaths: ['./src/**/*.graphql'],\n  path: join(process.cwd(), 'src/graphql.ts'),\n  outputAs: 'class',\n  watch: true,\n});"),s.Hb(),s.Hb(),s.Ib(284,"p"),s.lc(285,"To automatically generate the additional "),s.Ib(286,"code"),s.lc(287,"__typename"),s.Hb(),s.lc(288," field for every object type, enable the "),s.Ib(289,"code"),s.lc(290,"emitTypenameField"),s.Hb(),s.lc(291," option."),s.Hb(),s.Ib(292,"pre"),s.Ib(293,"code",16),s.lc(294,"\ndefinitionsFactory.generate({\n  // ...,\n  emitTypenameField: true,\n});"),s.Hb(),s.Hb(),s.Ib(295,"p"),s.lc(296,"To generate resolvers (queries, mutations, subscriptions) as plain fields without arguments, enable the "),s.Ib(297,"code"),s.lc(298,"skipResolverArgs"),s.Hb(),s.lc(299," option."),s.Hb(),s.Ib(300,"pre"),s.Ib(301,"code",16),s.lc(302,"\ndefinitionsFactory.generate({\n  // ...,\n  skipResolverArgs: true,\n});"),s.Hb(),s.Hb(),s.Ib(303,"p"),s.lc(304,"A fully working schema first sample is available "),s.Ib(305,"a",28),s.lc(306,"here"),s.Hb(),s.lc(307,"."),s.Hb(),s.Ib(308,"h4",29),s.Ib(309,"span"),s.lc(310,"Accessing generated schema"),s.Hb(),s.Hb(),s.Ib(311,"p"),s.lc(312,"In some circumstances (for example end-to-end tests), you may want to get a reference to the generated schema object. In end-to-end tests, you can then run queries using the "),s.Ib(313,"code"),s.lc(314,"graphql"),s.Hb(),s.lc(315," object without using any HTTP listeners."),s.Hb(),s.Ib(316,"p"),s.lc(317,"You can access the generated schema (in either the code first or schema first approach), using the "),s.Ib(318,"code"),s.lc(319,"GraphQLSchemaHost"),s.Hb(),s.lc(320," class:"),s.Hb(),s.Ib(321,"pre"),s.Ib(322,"code",16),s.lc(323,"\nconst { schema } = app.get(GraphQLSchemaHost);"),s.Hb(),s.Hb(),s.Ib(324,"blockquote",27),s.Ib(325,"strong"),s.lc(326,"Hint"),s.Hb(),s.lc(327," You must call the "),s.Ib(328,"code"),s.lc(329,"GraphQLSchemaHost#schema"),s.Hb(),s.lc(330," getter after the application has been initialized (after the "),s.Ib(331,"code"),s.lc(332,"onModuleInit"),s.Hb(),s.lc(333," hook has been triggered by either the "),s.Ib(334,"code"),s.lc(335,"app.listen()"),s.Hb(),s.lc(336," or "),s.Ib(337,"code"),s.lc(338,"app.init()"),s.Hb(),s.lc(339," method).\n"),s.Hb(),s.Ib(340,"h4",30),s.Ib(341,"span"),s.lc(342,"Async configuration"),s.Hb(),s.Hb(),s.Ib(343,"p"),s.lc(344,"When you need to pass module options asynchronously instead of statically, use the "),s.Ib(345,"code"),s.lc(346,"forRootAsync()"),s.Hb(),s.lc(347," method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."),s.Hb(),s.Ib(348,"p"),s.lc(349,"One technique is to use a factory function:"),s.Hb(),s.Ib(350,"pre"),s.Ib(351,"code",16),s.lc(352,"\nGraphQLModule.forRootAsync({\n  useFactory: () => ({\n    typePaths: ['./**/*.graphql'],\n  }),\n}),"),s.Hb(),s.Hb(),s.Ib(353,"p"),s.lc(354,"Like other factory providers, our factory function can be "),s.Ib(355,"a",31),s.lc(356,"async"),s.Hb(),s.lc(357," and can inject dependencies through "),s.Ib(358,"code"),s.lc(359,"inject"),s.Hb(),s.lc(360,"."),s.Hb(),s.Ib(361,"pre"),s.Ib(362,"code",16),s.lc(363,"\nGraphQLModule.forRootAsync({\n  imports: [ConfigModule],\n  useFactory: async (configService: ConfigService) => ({\n    typePaths: configService.getString('GRAPHQL_TYPE_PATHS'),\n  }),\n  inject: [ConfigService],\n}),"),s.Hb(),s.Hb(),s.Ib(364,"p"),s.lc(365,"Alternatively, you can configure the "),s.Ib(366,"code"),s.lc(367,"GraphQLModule"),s.Hb(),s.lc(368," using a class instead of a factory, as shown below:"),s.Hb(),s.Ib(369,"pre"),s.Ib(370,"code",16),s.lc(371,"\nGraphQLModule.forRootAsync({\n  useClass: GqlConfigService,\n}),"),s.Hb(),s.Hb(),s.Ib(372,"p"),s.lc(373,"The construction above instantiates "),s.Ib(374,"code"),s.lc(375,"GqlConfigService"),s.Hb(),s.lc(376," inside "),s.Ib(377,"code"),s.lc(378,"GraphQLModule"),s.Hb(),s.lc(379,", using it to create options object. Note that in this example, the "),s.Ib(380,"code"),s.lc(381,"GqlConfigService"),s.Hb(),s.lc(382," has to implement the "),s.Ib(383,"code"),s.lc(384,"GqlOptionsFactory"),s.Hb(),s.lc(385," interface, as shown below. The "),s.Ib(386,"code"),s.lc(387,"GraphQLModule"),s.Hb(),s.lc(388," will call the "),s.Ib(389,"code"),s.lc(390,"createGqlOptions()"),s.Hb(),s.lc(391," method on the instantiated object of the supplied class."),s.Hb(),s.Ib(392,"pre"),s.Ib(393,"code",16),s.lc(394,"\n@Injectable()\nclass GqlConfigService implements GqlOptionsFactory {\n  createGqlOptions(): GqlModuleOptions {\n    return {\n      typePaths: ['./**/*.graphql'],\n    };\n  }\n}"),s.Hb(),s.Hb(),s.Ib(395,"p"),s.lc(396,"If you want to reuse an existing options provider instead of creating a private copy inside the "),s.Ib(397,"code"),s.lc(398,"GraphQLModule"),s.Hb(),s.lc(399,", use the "),s.Ib(400,"code"),s.lc(401,"useExisting"),s.Hb(),s.lc(402," syntax."),s.Hb(),s.Ib(403,"pre"),s.Ib(404,"code",16),s.lc(405,"\nGraphQLModule.forRootAsync({\n  imports: [ConfigModule],\n  useExisting: ConfigService,\n}),"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a,i.a,j.a,a.f],encapsulation:2,changeDetection:0}),e})();const P=s.Kb(F);var C=o("rOQQ");let D=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return E(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-resolvers-map"]],features:[s.tb],decls:1054,vars:44,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/resolvers-map.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","resolvers"],["rel","nofollow","target","_blank","href","https://graphql.org/"],["appAnchor","","id","code-first"],["appAnchor","","id","object-types"],[1,"language-graphql"],[1,"filename"],["app12c37b730b560f07895d163e9213005064fb759f",""],[1,"language-typescript"],[1,"info"],["routerLink","/graphql/cli-plugin"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/"],["routerLink","/graphql/scalars"],["appa63cea0be12cf5ee1e4bca945b190b6cfcf5240a",""],["appdd69368b68c5678674fa72a70b78c630465ae013",""],["appAnchor","","id","code-first-resolver"],["app28907983c58f84968266464e62135db9a9f41697",""],["href","/graphql/resolvers#module"],[1,"warning"],["appAnchor","","id","query-type-names"],["rel","nofollow","target","_blank","href","http://graphql.org/learn/queries/"],["appe2927d0db5280e89f758e7611fd03ba3e67e36fe",""],["appAnchor","","id","query-decorator-options"],["appAnchor","","id","args-decorator-options"],["href","/controllers#route-parameters"],["appAnchor","","id","dedicated-arguments-class"],["app4f03bf4ff9e65966004ad1952e84f8b8e3d73e28",""],["routerLink","/techniques/validation"],["appAnchor","","id","class-inheritance"],["appAnchor","","id","generics"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/pagination/#pagination-and-edges"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"],["rel","nofollow","target","_blank","href","http://graphql.org/learn/schema/#type-language"],["appAnchor","","id","schema-first-resolver"],["appb1883b083c7948a4e9788b3af52c034cf93cf8b7",""],["app86634e95be2a87074be4e4dd00c04521ee394ec7",""],["appAnchor","","id","generating-types"],["app76099ff909bab790a8bc83c982f265d590a3eba4",""],["routerLink","/pipes"],["appAnchor","","id","graphql-argument-decorators"],["appAnchor","","id","module"],["appc7c1d217890101d5cbd57ca2abf3c08200cb69e9",""],["routerLink","/cli/overview"]],template:function(e,t){if(1&e){s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Resolvers"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Resolvers provide the instructions for turning a "),s.Ib(9,"a",6),s.lc(10,"GraphQL"),s.Hb(),s.lc(11," operation (a query, mutation, or subscription) into data. They return the same shape of data we specify in our schema -- either synchronously or as a promise that resolves to a result of that shape. Typically, you create a "),s.Ib(12,"strong"),s.lc(13,"resolver map"),s.Hb(),s.lc(14," manually. The "),s.Ib(15,"code"),s.lc(16,"@nestjs/graphql"),s.Hb(),s.lc(17," package, on the other hand, generates a resolver map automatically using the metadata provided by decorators you use to annotate classes. To demonstrate the process of using the package features to create a GraphQL API, we'll create a simple authors API."),s.Hb(),s.Ib(18,"h4",7),s.Ib(19,"span"),s.lc(20,"Code first"),s.Hb(),s.Hb(),s.Ib(21,"p"),s.lc(22,"In the code first approach, we don't follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The "),s.Ib(23,"code"),s.lc(24,"@nestjs/graphql"),s.Hb(),s.lc(25," package reads the metadata defined through the decorators and automatically generates the schema for you."),s.Hb(),s.Ib(26,"h4",8),s.Ib(27,"span"),s.lc(28,"Object types"),s.Hb(),s.Hb(),s.Ib(29,"p"),s.lc(30,"Most of the definitions in a GraphQL schema are "),s.Ib(31,"strong"),s.lc(32,"object types"),s.Hb(),s.lc(33,". Each object type you define should represent a domain object that an application client might need to interact with. For example, our sample API needs to be able to fetch a list of authors and their posts, so we should define the "),s.Ib(34,"code"),s.lc(35,"Author"),s.Hb(),s.lc(36," type and "),s.Ib(37,"code"),s.lc(38,"Post"),s.Hb(),s.lc(39," type to support this functionality."),s.Hb(),s.Ib(40,"p"),s.lc(41,"If we were using the schema first approach, we'd define such a schema with SDL like this:"),s.Hb(),s.Ib(42,"pre"),s.Ib(43,"code",9),s.lc(44,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}"),s.Hb(),s.Hb(),s.Ib(45,"p"),s.lc(46,"In this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:"),s.Hb(),s.Ib(47,"span",10),s.lc(48),s.Ub(49,"extension"),s.Gb(50,"app-tabs",null,11),s.Hb(),s.Ib(52,"pre"),s.Ib(53,"code",12),s.lc(54,"\nimport { Field, Int, ObjectType } from '@nestjs/graphql';\nimport { Post } from './post';\n\n@ObjectType()\nexport class Author {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ nullable: true })\n  lastName?: string;\n\n  @Field(type => [Post])\n  posts: Post[];\n}"),s.Hb(),s.Hb(),s.Ib(55,"blockquote",13),s.Ib(56,"strong"),s.lc(57,"Hint"),s.Hb(),s.lc(58," TypeScript's metadata reflection system has several limitations which make it impossible, for instance, to determine what properties a class consists of or recognize whether a given property is optional or required. Because of these limitations, we must either explicitly use the "),s.Ib(59,"code"),s.lc(60,"@Field()"),s.Hb(),s.lc(61," decorator in our schema definition classes to provide metadata about each field's GraphQL type and optionality, or use a "),s.Ib(62,"a",14),s.lc(63,"CLI plugin"),s.Hb(),s.lc(64," to generate these for us.\n"),s.Hb(),s.Ib(65,"p"),s.lc(66,"The "),s.Ib(67,"code"),s.lc(68,"Author"),s.Hb(),s.lc(69," object type, like any class, is made of a collection of fields, with each field declaring a type. A field's type corresponds to a "),s.Ib(70,"a",15),s.lc(71,"GraphQL type"),s.Hb(),s.lc(72,". A field's GraphQL type can be either another object type or a scalar type. A GraphQL scalar type is a primitive (like "),s.Ib(73,"code"),s.lc(74,"ID"),s.Hb(),s.lc(75,", "),s.Ib(76,"code"),s.lc(77,"String"),s.Hb(),s.lc(78,", "),s.Ib(79,"code"),s.lc(80,"Boolean"),s.Hb(),s.lc(81,", or "),s.Ib(82,"code"),s.lc(83,"Int"),s.Hb(),s.lc(84,") that resolves to a single value."),s.Hb(),s.Ib(85,"blockquote",13),s.Ib(86,"strong"),s.lc(87,"Hint"),s.Hb(),s.lc(88," In addition to GraphQL's built-in scalar types, you can define custom scalar types (read "),s.Ib(89,"a",16),s.lc(90,"more"),s.Hb(),s.lc(91,").\n"),s.Hb(),s.Ib(92,"p"),s.lc(93,"The above "),s.Ib(94,"code"),s.lc(95,"Author"),s.Hb(),s.lc(96," object type definition will cause Nest to "),s.Ib(97,"strong"),s.lc(98,"generate"),s.Hb(),s.lc(99," the SDL we showed above:"),s.Hb(),s.Ib(100,"pre"),s.Ib(101,"code",9),s.lc(102,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}"),s.Hb(),s.Hb(),s.Ib(103,"p"),s.lc(104,"The "),s.Ib(105,"code"),s.lc(106,"@Field()"),s.Hb(),s.lc(107," decorator accepts an optional type function (e.g., "),s.Ib(108,"code"),s.lc(109,"type => Int"),s.Hb(),s.lc(110,"), and optionally an options object."),s.Hb(),s.Ib(111,"p"),s.lc(112,"The type function is required when there's the potential for ambiguity between the TypeScript type system and the GraphQL type system. Specifically: it is "),s.Ib(113,"strong"),s.lc(114,"not"),s.Hb(),s.lc(115," required for "),s.Ib(116,"code"),s.lc(117,"string"),s.Hb(),s.lc(118," and "),s.Ib(119,"code"),s.lc(120,"boolean"),s.Hb(),s.lc(121," types; it "),s.Ib(122,"strong"),s.lc(123,"is"),s.Hb(),s.lc(124," required for arrays, numbers (which must be mapped to either a GraphQL "),s.Ib(125,"code"),s.lc(126,"Int"),s.Hb(),s.lc(127," or "),s.Ib(128,"code"),s.lc(129,"Float"),s.Hb(),s.lc(130,") and object types. The type function should simply return the desired GraphQL type (as shown in various examples in these chapters)."),s.Hb(),s.Ib(131,"p"),s.lc(132,"The options object can have any of the following key/value pairs:"),s.Hb(),s.Ib(133,"ul"),s.Ib(134,"li"),s.Ib(135,"code"),s.lc(136,"nullable"),s.Hb(),s.lc(137,": for specifying whether a field is nullable (in SDL, each field is non-nullable by default); "),s.Ib(138,"code"),s.lc(139,"boolean"),s.Hb(),s.Hb(),s.Ib(140,"li"),s.Ib(141,"code"),s.lc(142,"description"),s.Hb(),s.lc(143,": for setting a field description; "),s.Ib(144,"code"),s.lc(145,"string"),s.Hb(),s.Hb(),s.Ib(146,"li"),s.Ib(147,"code"),s.lc(148,"deprecationReason"),s.Hb(),s.lc(149,": for marking a field as deprecated; "),s.Ib(150,"code"),s.lc(151,"string"),s.Hb(),s.Hb(),s.Hb(),s.Ib(152,"p"),s.lc(153,"For example:"),s.Hb(),s.Ib(154,"pre"),s.Ib(155,"code",12),s.lc(156,"\n@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })\ntitle: string;"),s.Hb(),s.Hb(),s.Ib(157,"blockquote",13),s.Ib(158,"strong"),s.lc(159,"Hint"),s.Hb(),s.lc(160," You can also add a description to, or deprecate, the whole object type: "),s.Ib(161,"code"),s.lc(162),s.Hb(),s.lc(163,".\n"),s.Hb(),s.Ib(164,"p"),s.lc(165,"When the field is an array, we must manually indicate the array type in the "),s.Ib(166,"code"),s.lc(167,"Field()"),s.Hb(),s.lc(168," decorator's type function, as shown below:"),s.Hb(),s.Ib(169,"pre"),s.Ib(170,"code",12),s.lc(171,"\n@Field(type => [Post])\nposts: Post[];"),s.Hb(),s.Hb(),s.Ib(172,"blockquote",13),s.Ib(173,"strong"),s.lc(174,"Hint"),s.Hb(),s.lc(175," Using array bracket notation ("),s.Ib(176,"code"),s.lc(177,"[ ]"),s.Hb(),s.lc(178,"), we can indicate the depth of the array. For example, using "),s.Ib(179,"code"),s.lc(180,"[[Int]]"),s.Hb(),s.lc(181," would represent an integer matrix.\n"),s.Hb(),s.Ib(182,"p"),s.lc(183,"To declare that an array's items (not the array itself) are nullable, set the "),s.Ib(184,"code"),s.lc(185,"nullable"),s.Hb(),s.lc(186," property to "),s.Ib(187,"code"),s.lc(188,"'items'"),s.Hb(),s.lc(189," as shown below:"),s.Hb(),s.Ib(190,"pre"),s.Ib(191,"code",12),s.lc(192,"\n@Field(type => [Post], { nullable: 'items' })\nposts: Post[];"),s.Hb(),s.Hb(),s.Ib(193,"blockquote",13),s.Ib(194,"strong"),s.lc(195,"Hint"),s.Hb(),s.lc(196," If both the array and its items are nullable, set "),s.Ib(197,"code"),s.lc(198,"nullable"),s.Hb(),s.lc(199," to "),s.Ib(200,"code"),s.lc(201,"'itemsAndList'"),s.Hb(),s.lc(202," instead.\n"),s.Hb(),s.Ib(203,"p"),s.lc(204,"Now that the "),s.Ib(205,"code"),s.lc(206,"Author"),s.Hb(),s.lc(207," object type is created, let's define the "),s.Ib(208,"code"),s.lc(209,"Post"),s.Hb(),s.lc(210," object type."),s.Hb(),s.Ib(211,"span",10),s.lc(212),s.Ub(213,"extension"),s.Gb(214,"app-tabs",null,17),s.Hb(),s.Ib(216,"pre"),s.Ib(217,"code",12),s.lc(218,"\nimport { Field, Int, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Post {\n  @Field(type => Int)\n  id: number;\n\n  @Field()\n  title: string;\n\n  @Field(type => Int, { nullable: true })\n  votes?: number;\n}"),s.Hb(),s.Hb(),s.Ib(219,"p"),s.lc(220,"The "),s.Ib(221,"code"),s.lc(222,"Post"),s.Hb(),s.lc(223," object type will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(224,"span",10),s.lc(225),s.Ub(226,"extension"),s.Gb(227,"app-tabs",null,18),s.Hb(),s.Ib(229,"pre"),s.Ib(230,"code",9),s.lc(231,"\ntype Post {\n  id: Int!\n  title: String!\n  votes: Int\n}"),s.Hb(),s.Hb(),s.Ib(232,"h4",19),s.Ib(233,"span"),s.lc(234,"Code first resolver"),s.Hb(),s.Hb(),s.Ib(235,"p"),s.lc(236,"At this point, we've defined the objects (type definitions) that can exist in our data graph, but clients don't yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, a resolver class both defines resolver functions "),s.Ib(237,"strong"),s.lc(238,"and"),s.Hb(),s.lc(239," generates the "),s.Ib(240,"strong"),s.lc(241,"Query type"),s.Hb(),s.lc(242,". This will be clear as we work through the example below:"),s.Hb(),s.Ib(243,"span",10),s.lc(244),s.Ub(245,"extension"),s.Gb(246,"app-tabs",null,20),s.Hb(),s.Ib(248,"pre"),s.Ib(249,"code",12),s.lc(250,"\n@Resolver(of => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(returns => Author)\n  async author(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}"),s.Hb(),s.Hb(),s.Ib(251,"blockquote",13),s.Ib(252,"strong"),s.lc(253,"Hint"),s.Hb(),s.lc(254," All decorators (e.g., "),s.Ib(255,"code"),s.lc(256,"@Resolver"),s.Hb(),s.lc(257,", "),s.Ib(258,"code"),s.lc(259,"@ResolveField"),s.Hb(),s.lc(260,", "),s.Ib(261,"code"),s.lc(262,"@Args"),s.Hb(),s.lc(263,", etc.) are exported from the "),s.Ib(264,"code"),s.lc(265,"@nestjs/graphql"),s.Hb(),s.lc(266," package.\n"),s.Hb(),s.Ib(267,"p"),s.lc(268,"You can define multiple resolver classes. Nest will combine these at run time. See the "),s.Ib(269,"a",21),s.lc(270,"module"),s.Hb(),s.lc(271," section below for more on code organization."),s.Hb(),s.Ib(272,"blockquote",22),s.Ib(273,"strong"),s.lc(274,"Note"),s.Hb(),s.lc(275," The logic inside the "),s.Ib(276,"code"),s.lc(277,"AuthorsService"),s.Hb(),s.lc(278," and "),s.Ib(279,"code"),s.lc(280,"PostsService"),s.Hb(),s.lc(281," classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.\n"),s.Hb(),s.Ib(282,"p"),s.lc(283,"In the example above, we created the "),s.Ib(284,"code"),s.lc(285,"AuthorsResolver"),s.Hb(),s.lc(286," which defines one query resolver function and one field resolver function. To create a resolver, we create a class with resolver functions as methods, and annotate the class with the "),s.Ib(287,"code"),s.lc(288,"@Resolver()"),s.Hb(),s.lc(289," decorator."),s.Hb(),s.Ib(290,"p"),s.lc(291,"In this example, we defined a query handler to get the author object based on the "),s.Ib(292,"code"),s.lc(293,"id"),s.Hb(),s.lc(294," sent in the request. To specify that the method is a query handler, use the "),s.Ib(295,"code"),s.lc(296,"@Query()"),s.Hb(),s.lc(297," decorator."),s.Hb(),s.Ib(298,"p"),s.lc(299,"The argument passed to the "),s.Ib(300,"code"),s.lc(301,"@Resolver()"),s.Hb(),s.lc(302," decorator is optional, but comes into play when our graph becomes non-trivial. It's used to supply a parent object used by field resolver functions as they traverse down through an object graph."),s.Hb(),s.Ib(303,"p"),s.lc(304,"In our example, since the class includes a "),s.Ib(305,"strong"),s.lc(306,"field resolver"),s.Hb(),s.lc(307," function (for the "),s.Ib(308,"code"),s.lc(309,"posts"),s.Hb(),s.lc(310," property of the "),s.Ib(311,"code"),s.lc(312,"Author"),s.Hb(),s.lc(313," object type), we "),s.Ib(314,"strong"),s.lc(315,"must"),s.Hb(),s.lc(316," supply the "),s.Ib(317,"code"),s.lc(318,"@Resolver()"),s.Hb(),s.lc(319," decorator with a value to indicate which class is the parent type (i.e., the corresponding "),s.Ib(320,"code"),s.lc(321,"ObjectType"),s.Hb(),s.lc(322," class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it's necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author's posts array with a field resolver that calls a service which takes the author's "),s.Ib(323,"code"),s.lc(324,"id"),s.Hb(),s.lc(325," as an argument. Hence the need to identify the parent object in the "),s.Ib(326,"code"),s.lc(327,"@Resolver()"),s.Hb(),s.lc(328," decorator. Note the corresponding use of the "),s.Ib(329,"code"),s.lc(330,"@Parent()"),s.Hb(),s.lc(331," method parameter decorator to then extract a reference to that parent object in the field resolver."),s.Hb(),s.Ib(332,"p"),s.lc(333,"We can define multiple "),s.Ib(334,"code"),s.lc(335,"@Query()"),s.Hb(),s.lc(336," resolver functions (both within this class, and in any other resolver class), and they will be aggregated into a single "),s.Ib(337,"strong"),s.lc(338,"Query type"),s.Hb(),s.lc(339," definition in the generated SDL along with the appropriate entries in the resolver map. This allows you to define queries close to the models and services that they use, and to keep them well organized in modules."),s.Hb(),s.Ib(340,"h4",23),s.Ib(341,"span"),s.lc(342,"Query type names"),s.Hb(),s.Hb(),s.Ib(343,"p"),s.lc(344,"In the above examples, the "),s.Ib(345,"code"),s.lc(346,"@Query()"),s.Hb(),s.lc(347," decorator generates a GraphQL schema query type name based on the method name. For example, consider the following construction from the example above:"),s.Hb(),s.Ib(348,"pre"),s.Ib(349,"code",12),s.lc(350,"\n@Query(returns => Author)\nasync author(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}"),s.Hb(),s.Hb(),s.Ib(351,"p"),s.lc(352,"This generates the following entry for the author query in our schema (the query type uses the same name as the method name):"),s.Hb(),s.Ib(353,"pre"),s.Ib(354,"code",9),s.lc(355,"\ntype Query {\n  author(id: Int!): Author\n}"),s.Hb(),s.Hb(),s.Ib(356,"blockquote",13),s.Ib(357,"strong"),s.lc(358,"Hint"),s.Hb(),s.lc(359," Learn more about GraphQL queries "),s.Ib(360,"a",24),s.lc(361,"here"),s.Hb(),s.lc(362,".\n"),s.Hb(),s.Ib(363,"p"),s.lc(364,"Conventionally, we prefer to decouple these names; for example, we prefer to use a name like "),s.Ib(365,"code"),s.lc(366,"getAuthor()"),s.Hb(),s.lc(367," for our query handler method, but still use "),s.Ib(368,"code"),s.lc(369,"author"),s.Hb(),s.lc(370," for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the "),s.Ib(371,"code"),s.lc(372,"@Query()"),s.Hb(),s.lc(373," and "),s.Ib(374,"code"),s.lc(375,"@ResolveField()"),s.Hb(),s.lc(376," decorators, as shown below:"),s.Hb(),s.Ib(377,"span",10),s.lc(378),s.Ub(379,"extension"),s.Gb(380,"app-tabs",null,25),s.Hb(),s.Ib(382,"pre"),s.Ib(383,"code",12),s.lc(384,"\n@Resolver(of => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(returns => Author, { name: 'author' })\n  async getAuthor(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts', returns => [Post])\n  async getPosts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}"),s.Hb(),s.Hb(),s.Ib(385,"p"),s.lc(386,"The "),s.Ib(387,"code"),s.lc(388,"getAuthor"),s.Hb(),s.lc(389," handler method above will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(390,"pre"),s.Ib(391,"code",9),s.lc(392,"\ntype Query {\n  author(id: Int!): Author\n}"),s.Hb(),s.Hb(),s.Ib(393,"h4",26),s.Ib(394,"span"),s.lc(395,"Query decorator options"),s.Hb(),s.Hb(),s.Ib(396,"p"),s.lc(397,"The "),s.Ib(398,"code"),s.lc(399,"@Query()"),s.Hb(),s.lc(400," decorator's options object (where we pass "),s.Ib(401,"code"),s.lc(402),s.Hb(),s.lc(403," above) accepts a number of key/value pairs:"),s.Hb(),s.Ib(404,"ul"),s.Ib(405,"li"),s.Ib(406,"code"),s.lc(407,"name"),s.Hb(),s.lc(408,": name of the query; a "),s.Ib(409,"code"),s.lc(410,"string"),s.Hb(),s.Hb(),s.Ib(411,"li"),s.Ib(412,"code"),s.lc(413,"description"),s.Hb(),s.lc(414,": a description that will be used to generate GraphQL schema documentation (e.g., in GraphQL playground); a "),s.Ib(415,"code"),s.lc(416,"string"),s.Hb(),s.Hb(),s.Ib(417,"li"),s.Ib(418,"code"),s.lc(419,"deprecationReason"),s.Hb(),s.lc(420,": sets query metadata to show the query as deprecated (e.g., in GraphQL playground); a "),s.Ib(421,"code"),s.lc(422,"string"),s.Hb(),s.Hb(),s.Ib(423,"li"),s.Ib(424,"code"),s.lc(425,"nullable"),s.Hb(),s.lc(426,": whether the query can return a null data response; "),s.Ib(427,"code"),s.lc(428,"boolean"),s.Hb(),s.lc(429," or "),s.Ib(430,"code"),s.lc(431,"'items'"),s.Hb(),s.lc(432," or "),s.Ib(433,"code"),s.lc(434,"'itemsAndList'"),s.Hb(),s.lc(435," (see above for details of "),s.Ib(436,"code"),s.lc(437,"'items'"),s.Hb(),s.lc(438," and "),s.Ib(439,"code"),s.lc(440,"'itemsAndList'"),s.Hb(),s.lc(441,")"),s.Hb(),s.Hb(),s.Ib(442,"h4",27),s.Ib(443,"span"),s.lc(444,"Args decorator options"),s.Hb(),s.Hb(),s.Ib(445,"p"),s.lc(446,"Use the "),s.Ib(447,"code"),s.lc(448,"@Args()"),s.Hb(),s.lc(449," decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to "),s.Ib(450,"a",28),s.lc(451,"REST route parameter argument extraction"),s.Hb(),s.lc(452,"."),s.Hb(),s.Ib(453,"p"),s.lc(454,"Usually your "),s.Ib(455,"code"),s.lc(456,"@Args()"),s.Hb(),s.lc(457," decorator will be simple, and not require an object argument as seen with the "),s.Ib(458,"code"),s.lc(459,"getAuthor()"),s.Hb(),s.lc(460," method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument."),s.Hb(),s.Ib(461,"pre"),s.Ib(462,"code",12),s.lc(463,"\n@Args('id') id: string"),s.Hb(),s.Hb(),s.Ib(464,"p"),s.lc(465,"In the "),s.Ib(466,"code"),s.lc(467,"getAuthor()"),s.Hb(),s.lc(468," case, the "),s.Ib(469,"code"),s.lc(470,"number"),s.Hb(),s.lc(471," type is used, which presents a challenge. The "),s.Ib(472,"code"),s.lc(473,"number"),s.Hb(),s.lc(474," TypeScript type doesn't give us enough information about the expected GraphQL representation (e.g., "),s.Ib(475,"code"),s.lc(476,"Int"),s.Hb(),s.lc(477," vs. "),s.Ib(478,"code"),s.lc(479,"Float"),s.Hb(),s.lc(480,"). Thus we have to "),s.Ib(481,"strong"),s.lc(482,"explicitly"),s.Hb(),s.lc(483," pass the type reference. We do that by passing a second argument to the "),s.Ib(484,"code"),s.lc(485,"Args()"),s.Hb(),s.lc(486," decorator, containing argument options, as shown below:"),s.Hb(),s.Ib(487,"pre"),s.Ib(488,"code",12),s.lc(489,"\n@Query(returns => Author, { name: 'author' })\nasync getAuthor(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}"),s.Hb(),s.Hb(),s.Ib(490,"p"),s.lc(491,"The options object allows us to specify the following optional key value pairs:"),s.Hb(),s.Ib(492,"ul"),s.Ib(493,"li"),s.Ib(494,"code"),s.lc(495,"type"),s.Hb(),s.lc(496,": a function returning the GraphQL type"),s.Hb(),s.Ib(497,"li"),s.Ib(498,"code"),s.lc(499,"defaultValue"),s.Hb(),s.lc(500,": a default value; "),s.Ib(501,"code"),s.lc(502,"any"),s.Hb(),s.Hb(),s.Ib(503,"li"),s.Ib(504,"code"),s.lc(505,"description"),s.Hb(),s.lc(506,": description metadata; "),s.Ib(507,"code"),s.lc(508,"string"),s.Hb(),s.Hb(),s.Ib(509,"li"),s.Ib(510,"code"),s.lc(511,"deprecationReason"),s.Hb(),s.lc(512,": to deprecate a field and provide meta data describing why; "),s.Ib(513,"code"),s.lc(514,"string"),s.Hb(),s.Hb(),s.Ib(515,"li"),s.Ib(516,"code"),s.lc(517,"nullable"),s.Hb(),s.lc(518,": whether the field is nullable"),s.Hb(),s.Hb(),s.Ib(519,"p"),s.lc(520,"Query handler methods can take multiple arguments. Let's imagine that we want to fetch an author based on its "),s.Ib(521,"code"),s.lc(522,"firstName"),s.Hb(),s.lc(523," and "),s.Ib(524,"code"),s.lc(525,"lastName"),s.Hb(),s.lc(526,". In this case, we can call "),s.Ib(527,"code"),s.lc(528,"@Args"),s.Hb(),s.lc(529," twice:"),s.Hb(),s.Ib(530,"pre"),s.Ib(531,"code",12),s.lc(532,"\ngetAuthor(\n  @Args( 'firstName', { nullable: true }) firstName?: string,\n  @Args( 'lastName', { defaultValue: '' }) lastName?: string,\n) {}"),s.Hb(),s.Hb(),s.Ib(533,"h4",29),s.Ib(534,"span"),s.lc(535,"Dedicated arguments class"),s.Hb(),s.Hb(),s.Ib(536,"p"),s.lc(537,"With inline "),s.Ib(538,"code"),s.lc(539,"@Args()"),s.Hb(),s.lc(540," calls, code like the example above becomes bloated. Instead, you can create a dedicated "),s.Ib(541,"code"),s.lc(542,"GetAuthorArgs"),s.Hb(),s.lc(543," arguments class and access it in the handler method as follows:"),s.Hb(),s.Ib(544,"pre"),s.Ib(545,"code",12),s.lc(546,"\n@Args() args: GetAuthorArgs"),s.Hb(),s.Hb(),s.Ib(547,"p"),s.lc(548,"Create the "),s.Ib(549,"code"),s.lc(550,"GetAuthorArgs"),s.Hb(),s.lc(551," class using "),s.Ib(552,"code"),s.lc(553,"@ArgsType()"),s.Hb(),s.lc(554," as shown below:"),s.Hb(),s.Ib(555,"span",10),s.lc(556),s.Ub(557,"extension"),s.Gb(558,"app-tabs",null,30),s.Hb(),s.Ib(560,"pre"),s.Ib(561,"code",12),s.lc(562,"\nimport { MinLength } from 'class-validator';\nimport { Field, ArgsType } from '@nestjs/graphql';\n\n@ArgsType()\nclass GetAuthorArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}"),s.Hb(),s.Hb(),s.Ib(563,"blockquote",13),s.Ib(564,"strong"),s.lc(565,"Hint"),s.Hb(),s.lc(566," Again, due to TypeScript's metadata reflection system limitations, it's required to either use the ");s.Ib(567,"code"),s.lc(568,"@Field"),s.Hb(),s.lc(569," decorator to manually indicate type and optionality, or use a "),s.Ib(570,"a",14),s.lc(571,"CLI plugin"),s.Hb(),s.lc(572,".\n"),s.Hb(),s.Ib(573,"p"),s.lc(574,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(575,"pre"),s.Ib(576,"code",9),s.lc(577,"\ntype Query {\n  author(firstName: String, lastName: String = ''): Author\n}"),s.Hb(),s.Hb(),s.Ib(578,"blockquote",13),s.Ib(579,"strong"),s.lc(580,"Hint"),s.Hb(),s.lc(581," Note that arguments classes like "),s.Ib(582,"code"),s.lc(583,"GetAuthorArgs"),s.Hb(),s.lc(584," play very well with the "),s.Ib(585,"code"),s.lc(586,"ValidationPipe"),s.Hb(),s.lc(587," (read "),s.Ib(588,"a",31),s.lc(589,"more"),s.Hb(),s.lc(590,").\n"),s.Hb(),s.Ib(591,"h4",32),s.Ib(592,"span"),s.lc(593,"Class inheritance"),s.Hb(),s.Hb(),s.Ib(594,"p"),s.lc(595,"You can use standard TypeScript class inheritance to create base classes with generic utility type features (fields and field properties, validations, etc.) that can be extended. For example, you may have a set of pagination related arguments that always include the standard "),s.Ib(596,"code"),s.lc(597,"offset"),s.Hb(),s.lc(598," and "),s.Ib(599,"code"),s.lc(600,"limit"),s.Hb(),s.lc(601," fields, but also other index fields that are type-specific. You can set up a class hierarchy as shown below."),s.Hb(),s.Ib(602,"p"),s.lc(603,"Base "),s.Ib(604,"code"),s.lc(605,"@ArgsType()"),s.Hb(),s.lc(606," class:"),s.Hb(),s.Ib(607,"pre"),s.Ib(608,"code",12),s.lc(609,"\n@ArgsType()\nclass PaginationArgs {\n  @Field((type) => Int)\n  offset: number = 0;\n\n  @Field((type) => Int)\n  limit: number = 10;\n}"),s.Hb(),s.Hb(),s.Ib(610,"p"),s.lc(611,"Type specific sub-class of the base "),s.Ib(612,"code"),s.lc(613,"@ArgsType()"),s.Hb(),s.lc(614," class:"),s.Hb(),s.Ib(615,"pre"),s.Ib(616,"code",12),s.lc(617,"\n@ArgsType()\nclass GetAuthorArgs extends PaginationArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}"),s.Hb(),s.Hb(),s.Ib(618,"p"),s.lc(619,"The same approach can be taken with "),s.Ib(620,"code"),s.lc(621,"@ObjectType()"),s.Hb(),s.lc(622," objects. Define generic properties on the base class:"),s.Hb(),s.Ib(623,"pre"),s.Ib(624,"code",12),s.lc(625,"\n@ObjectType()\nclass Character {\n  @Field((type) => Int)\n  id: number;\n\n  @Field()\n  name: string;\n}"),s.Hb(),s.Hb(),s.Ib(626,"p"),s.lc(627,"Add type-specific properties on sub-classes:"),s.Hb(),s.Ib(628,"pre"),s.Ib(629,"code",12),s.lc(630,"\n@ObjectType()\nclass Warrior extends Character {\n  @Field()\n  level: number;\n}"),s.Hb(),s.Hb(),s.Ib(631,"p"),s.lc(632,"You can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic "),s.Ib(633,"code"),s.lc(634,"findAll"),s.Hb(),s.lc(635," query, use a construction like this:"),s.Hb(),s.Ib(636,"pre"),s.Ib(637,"code",12),s.lc(638,"\nfunction BaseResolver<T extends Type<unknown>>(classRef: T): any {\n  @Resolver({ isAbstract: true })\n  abstract class BaseResolverHost {\n    @Query((type) => [classRef], { name: `findAll${classRef.name}` })\n    async findAll(): Promise<T[]> {\n      return [];\n    }\n  }\n  return BaseResolverHost;\n}"),s.Hb(),s.Hb(),s.Ib(639,"p"),s.lc(640,"Note the following:"),s.Hb(),s.Ib(641,"ul"),s.Ib(642,"li"),s.lc(643,"an explicit return type ("),s.Ib(644,"code"),s.lc(645,"any"),s.Hb(),s.lc(646," above) is required: otherwise TypeScript complains about the usage of a private class definition. Recommended: define an interface instead of using "),s.Ib(647,"code"),s.lc(648,"any"),s.Hb(),s.lc(649,"."),s.Hb(),s.Ib(650,"li"),s.Ib(651,"code"),s.lc(652,"Type"),s.Hb(),s.lc(653," is imported from the "),s.Ib(654,"code"),s.lc(655,"@nestjs/common"),s.Hb(),s.lc(656," package"),s.Hb(),s.Ib(657,"li"),s.lc(658,"The "),s.Ib(659,"code"),s.lc(660,"isAbstract: true"),s.Hb(),s.lc(661," property indicates that SDL (Schema Definition Language statements) shouldn't be generated for this class. Note, you can set this property for other types as well to suppress SDL generation."),s.Hb(),s.Hb(),s.Ib(662,"p"),s.lc(663,"Here's how you could generate a concrete sub-class of the "),s.Ib(664,"code"),s.lc(665,"BaseResolver"),s.Hb(),s.lc(666,":"),s.Hb(),s.Ib(667,"pre"),s.Ib(668,"code",12),s.lc(669,"\n@Resolver((of) => Recipe)\nexport class RecipesResolver extends BaseResolver(Recipe) {\n  constructor(private recipesService: RecipesService) {\n    super();\n  }\n}"),s.Hb(),s.Hb(),s.Ib(670,"p"),s.lc(671,"This construct would generated the following SDL:"),s.Hb(),s.Ib(672,"pre"),s.Ib(673,"code",9),s.lc(674,"\ntype Query {\n  findAllRecipe: [Recipe!]!\n}"),s.Hb(),s.Hb(),s.Ib(675,"h4",33),s.Ib(676,"span"),s.lc(677,"Generics"),s.Hb(),s.Hb(),s.Ib(678,"p"),s.lc(679,"We saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here's a sample cursor-based pagination implementation based on "),s.Ib(680,"a",34),s.lc(681,"this documentation"),s.Hb(),s.lc(682,":"),s.Hb(),s.Ib(683,"pre"),s.Ib(684,"code",12),s.lc(685,"\nimport { Field, ObjectType, Int } from '@nestjs/graphql';\nimport { Type } from '@nestjs/common';\n\nexport function Paginated<T>(classRef: Type<T>): any {\n  @ObjectType(`${classRef.name}Edge`)\n  abstract class EdgeType {\n    @Field((type) => String)\n    cursor: string;\n\n    @Field((type) => classRef)\n    node: T;\n  }\n\n  @ObjectType({ isAbstract: true })\n  abstract class PaginatedType {\n    @Field((type) => [EdgeType], { nullable: true })\n    edges: EdgeType[];\n\n    @Field((type) => [classRef], { nullable: true })\n    nodes: T[];\n\n    @Field((type) => Int)\n    totalCount: number;\n\n    @Field()\n    hasNextPage: boolean;\n  }\n  return PaginatedType;\n}"),s.Hb(),s.Hb(),s.Ib(686,"p"),s.lc(687,"With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:"),s.Hb(),s.Ib(688,"pre"),s.Ib(689,"code",12),s.lc(690,"\n@ObjectType()\nclass PaginatedAuthor extends Paginated(Author) {}"),s.Hb(),s.Hb(),s.Ib(691,"h4",35),s.Ib(692,"span"),s.lc(693,"Schema first"),s.Hb(),s.Hb(),s.Ib(694,"p"),s.lc(695,"As mentioned in the "),s.Ib(696,"a",36),s.lc(697,"previous"),s.Hb(),s.lc(698," chapter, in the schema first approach we start by manually defining schema types in SDL (read "),s.Ib(699,"a",37),s.lc(700,"more"),s.Hb(),s.lc(701,"). Consider the following SDL type definitions."),s.Hb(),s.Ib(702,"blockquote",13),s.Ib(703,"strong"),s.lc(704,"Hint"),s.Hb(),s.lc(705," For convenience in this chapter, we've aggregated all of the SDL in one location (e.g., one "),s.Ib(706,"code"),s.lc(707,".graphql"),s.Hb(),s.lc(708," file, as shown below). In practice, you may find it appropriate to organize your code in a modular fashion. For example, it can be helpful to create individual SDL files with type definitions representing each domain entity, along with related services, resolver code, and the Nest module definition class, in a dedicated directory for that entity. Nest will aggregate all the individual schema type definitions at run time.\n"),s.Hb(),s.Ib(709,"pre"),s.Ib(710,"code",9),s.lc(711,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String!\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}"),s.Hb(),s.Hb(),s.Ib(712,"h4",38),s.Ib(713,"span"),s.lc(714,"Schema first resolver"),s.Hb(),s.Hb(),s.Ib(715,"p"),s.lc(716,"The schema above exposes a single query - "),s.Ib(717,"code"),s.lc(718,"author(id: Int!): Author"),s.Hb(),s.lc(719,"."),s.Hb(),s.Ib(720,"blockquote",13),s.Ib(721,"strong"),s.lc(722,"Hint"),s.Hb(),s.lc(723," Learn more about GraphQL queries "),s.Ib(724,"a",24),s.lc(725,"here"),s.Hb(),s.lc(726,".\n"),s.Hb(),s.Ib(727,"p"),s.lc(728,"Let's now create an "),s.Ib(729,"code"),s.lc(730,"AuthorsResolver"),s.Hb(),s.lc(731," class that resolves author queries:"),s.Hb(),s.Ib(732,"span",10),s.lc(733),s.Ub(734,"extension"),s.Gb(735,"app-tabs",null,39),s.Hb(),s.Ib(737,"pre"),s.Ib(738,"code",12),s.lc(739,"\n@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query()\n  async author(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}"),s.Hb(),s.Hb(),s.Ib(740,"blockquote",13),s.Ib(741,"strong"),s.lc(742,"Hint"),s.Hb(),s.lc(743," All decorators (e.g., "),s.Ib(744,"code"),s.lc(745,"@Resolver"),s.Hb(),s.lc(746,", "),s.Ib(747,"code"),s.lc(748,"@ResolveField"),s.Hb(),s.lc(749,", "),s.Ib(750,"code"),s.lc(751,"@Args"),s.Hb(),s.lc(752,", etc.) are exported from the "),s.Ib(753,"code"),s.lc(754,"@nestjs/graphql"),s.Hb(),s.lc(755," package.\n"),s.Hb(),s.Ib(756,"blockquote",22),s.Ib(757,"strong"),s.lc(758,"Note"),s.Hb(),s.lc(759," The logic inside the "),s.Ib(760,"code"),s.lc(761,"AuthorsService"),s.Hb(),s.lc(762," and "),s.Ib(763,"code"),s.lc(764,"PostsService"),s.Hb(),s.lc(765," classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.\n"),s.Hb(),s.Ib(766,"p"),s.lc(767,"The "),s.Ib(768,"code"),s.lc(769,"@Resolver()"),s.Hb(),s.lc(770," decorator is required. It takes an optional string argument with the name of a class. This class name is required whenever the class includes "),s.Ib(771,"code"),s.lc(772,"@ResolveField()"),s.Hb(),s.lc(773," decorators to inform Nest that the decorated method is associated with a parent type (the "),s.Ib(774,"code"),s.lc(775,"Author"),s.Hb(),s.lc(776," type in our current example). Alternatively, instead of setting "),s.Ib(777,"code"),s.lc(778,"@Resolver()"),s.Hb(),s.lc(779," at the top of the class, this can be done for each method:"),s.Hb(),s.Ib(780,"pre"),s.Ib(781,"code",12),s.lc(782,"\n@Resolver('Author')\n@ResolveField()\nasync posts(@Parent() author) {\n  const { id } = author;\n  return this.postsService.findAll({ authorId: id });\n}"),s.Hb(),s.Hb(),s.Ib(783,"p"),s.lc(784,"In this case ("),s.Ib(785,"code"),s.lc(786,"@Resolver()"),s.Hb(),s.lc(787," decorator at the method level), if you have multiple "),s.Ib(788,"code"),s.lc(789,"@ResolveField()"),s.Hb(),s.lc(790," decorators inside a class, you must add "),s.Ib(791,"code"),s.lc(792,"@Resolver()"),s.Hb(),s.lc(793," to all of them. This is not considered the best practice (as it creates extra overhead)."),s.Hb(),s.Ib(794,"blockquote",13),s.Ib(795,"strong"),s.lc(796,"Hint"),s.Hb(),s.lc(797," Any class name argument passed to "),s.Ib(798,"code"),s.lc(799,"@Resolver()"),s.Hb(),s.Ib(800,"strong"),s.lc(801,"does not"),s.Hb(),s.lc(802," affect queries ("),s.Ib(803,"code"),s.lc(804,"@Query()"),s.Hb(),s.lc(805," decorator) or mutations ("),s.Ib(806,"code"),s.lc(807,"@Mutation()"),s.Hb(),s.lc(808," decorator).\n"),s.Hb(),s.Ib(809,"blockquote",22),s.Ib(810,"strong"),s.lc(811,"Warning"),s.Hb(),s.lc(812," Using the "),s.Ib(813,"code"),s.lc(814,"@Resolver"),s.Hb(),s.lc(815," decorator at the method level is not supported with the "),s.Ib(816,"strong"),s.lc(817,"code first"),s.Hb(),s.lc(818," approach.\n"),s.Hb(),s.Ib(819,"p"),s.lc(820,"In the above examples, the "),s.Ib(821,"code"),s.lc(822,"@Query()"),s.Hb(),s.lc(823," and "),s.Ib(824,"code"),s.lc(825,"@ResolveField()"),s.Hb(),s.lc(826," decorators are associated with GraphQL schema types based on the method name. For example, consider the following construction from the example above:"),s.Hb(),s.Ib(827,"pre"),s.Ib(828,"code",12),s.lc(829,"\n@Query()\nasync author(@Args('id') id: number) {\n  return this.authorsService.findOneById(id);\n}"),s.Hb(),s.Hb(),s.Ib(830,"p"),s.lc(831,"This generates the following entry for the author query in our schema (the query type uses the same name as the method name):"),s.Hb(),s.Ib(832,"pre"),s.Ib(833,"code",9),s.lc(834,"\ntype Query {\n  author(id: Int!): Author\n}"),s.Hb(),s.Hb(),s.Ib(835,"p"),s.lc(836,"Conventionally, we would prefer to decouple these, using names like "),s.Ib(837,"code"),s.lc(838,"getAuthor()"),s.Hb(),s.lc(839," or "),s.Ib(840,"code"),s.lc(841,"getPosts()"),s.Hb(),s.lc(842," for our resolver methods. We can easily do this by passing the mapping name as an argument to the decorator, as shown below:"),s.Hb(),s.Ib(843,"span",10),s.lc(844),s.Ub(845,"extension"),s.Gb(846,"app-tabs",null,40),s.Hb(),s.Ib(848,"pre"),s.Ib(849,"code",12),s.lc(850,"\n@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query('author')\n  async getAuthor(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts')\n  async getPosts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}"),s.Hb(),s.Hb(),s.Ib(851,"h4",41),s.Ib(852,"span"),s.lc(853,"Generating types"),s.Hb(),s.Hb(),s.Ib(854,"p"),s.lc(855,"Assuming that we use the schema first approach and have enabled the typings generation feature (with "),s.Ib(856,"code"),s.lc(857,"outputAs: 'class'"),s.Hb(),s.lc(858," as shown in the "),s.Ib(859,"a",36),s.lc(860,"previous"),s.Hb(),s.lc(861," chapter), once you run the application it will generate the following file (in the location you specified in the "),s.Ib(862,"code"),s.lc(863,"GraphQLModule.forRoot()"),s.Hb(),s.lc(864," method. For example, in "),s.Ib(865,"code"),s.lc(866,"src/graphql.ts"),s.Hb(),s.lc(867,")"),s.Hb(),s.Ib(868,"span",10),s.lc(869),s.Ub(870,"extension"),s.Gb(871,"app-tabs",null,42),s.Hb(),s.Ib(873,"pre"),s.Ib(874,"code",12),s.lc(875,"\nexport class Author {\n  id: number;\n  firstName?: string;\n  lastName?: string;\n  posts?: Post[];\n}\n\nexport class Post {\n  id: number;\n  title: string;\n  votes?: number;\n}\n\nexport abstract class IQuery {\n  abstract author(id: number): Author | Promise<Author>;\n}"),s.Hb(),s.Hb(),s.Ib(876,"p"),s.lc(877,"By generating classes (instead of the default technique of generating interfaces), you can use declarative validation "),s.Ib(878,"strong"),s.lc(879,"decorators"),s.Hb(),s.lc(880," in combination with the schema first approach, which is an extremely useful technique (read "),s.Ib(881,"a",31),s.lc(882,"more"),s.Hb(),s.lc(883,"). For example, you could add "),s.Ib(884,"code"),s.lc(885,"class-validator"),s.Hb(),s.lc(886," decorators to the generated "),s.Ib(887,"code"),s.lc(888,"CreatePostInput"),s.Hb(),s.lc(889," class as shown below to enforce minimum and maximum string lengths on the "),s.Ib(890,"code"),s.lc(891,"title"),s.Hb(),s.lc(892," field:"),s.Hb(),s.Ib(893,"pre"),s.Ib(894,"code",12),s.lc(895,"\nimport { MinLength, MaxLength } from 'class-validator';\n\nexport class CreatePostInput {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}"),s.Hb(),s.Hb(),s.Ib(896,"blockquote",22),s.Ib(897,"strong"),s.lc(898,"Notice"),s.Hb(),s.lc(899," To enable auto-validation of your inputs (and parameters), use "),s.Ib(900,"code"),s.lc(901,"ValidationPipe"),s.Hb(),s.lc(902,". Read more about validation "),s.Ib(903,"a",31),s.lc(904,"here"),s.Hb(),s.lc(905," and more specifically about pipes "),s.Ib(906,"a",43),s.lc(907,"here"),s.Hb(),s.lc(908,".\n"),s.Hb(),s.Ib(909,"p"),s.lc(910,"However, if you add decorators directly to the automatically generated file, they will be "),s.Ib(911,"strong"),s.lc(912,"overwritten"),s.Hb(),s.lc(913," each time the file is generated. Instead, create a separate file and simply extend the generated class."),s.Hb(),s.Ib(914,"pre"),s.Ib(915,"code",12),s.lc(916,"\nimport { MinLength, MaxLength } from 'class-validator';\nimport { Post } from '../../graphql.ts';\n\nexport class CreatePostInput extends Post {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}"),s.Hb(),s.Hb(),s.Ib(917,"h4",44),s.Ib(918,"span"),s.lc(919,"GraphQL argument decorators"),s.Hb(),s.Hb(),s.Ib(920,"p"),s.lc(921,"We can access the standard GraphQL resolver arguments using dedicated decorators. Below is a comparison of the Nest decorators and the plain Apollo parameters they represent."),s.Hb(),s.Ib(922,"table"),s.Ib(923,"tbody"),s.Ib(924,"tr"),s.Ib(925,"td"),s.Ib(926,"code"),s.lc(927,"@Root()"),s.Hb(),s.lc(928," and "),s.Ib(929,"code"),s.lc(930,"@Parent()"),s.Hb(),s.Hb(),s.Ib(931,"td"),s.Ib(932,"code"),s.lc(933,"root"),s.Hb(),s.lc(934,"/"),s.Ib(935,"code"),s.lc(936,"parent"),s.Hb(),s.Hb(),s.Hb(),s.Ib(937,"tr"),s.Ib(938,"td"),s.Ib(939,"code"),s.lc(940,"@Context(param?: string)"),s.Hb(),s.Hb(),s.Ib(941,"td"),s.Ib(942,"code"),s.lc(943,"context"),s.Hb(),s.lc(944," / "),s.Ib(945,"code"),s.lc(946,"context[param]"),s.Hb(),s.Hb(),s.Hb(),s.Ib(947,"tr"),s.Ib(948,"td"),s.Ib(949,"code"),s.lc(950,"@Info(param?: string)"),s.Hb(),s.Hb(),s.Ib(951,"td"),s.Ib(952,"code"),s.lc(953,"info"),s.Hb(),s.lc(954," / "),s.Ib(955,"code"),s.lc(956,"info[param]"),s.Hb(),s.Hb(),s.Hb(),s.Ib(957,"tr"),s.Ib(958,"td"),s.Ib(959,"code"),s.lc(960,"@Args(param?: string)"),s.Hb(),s.Hb(),s.Ib(961,"td"),s.Ib(962,"code"),s.lc(963,"args"),s.Hb(),s.lc(964," / "),s.Ib(965,"code"),s.lc(966,"args[param]"),s.Hb(),s.Hb(),s.Hb(),s.Hb(),s.Hb(),s.Ib(967,"p"),s.lc(968,"These arguments have the following meanings:"),s.Hb(),s.Ib(969,"ul"),s.Ib(970,"li"),s.Ib(971,"code"),s.lc(972,"root"),s.Hb(),s.lc(973,": an object that contains the result returned from the resolver on the parent field, or, in the case of a top-level "),s.Ib(974,"code"),s.lc(975,"Query"),s.Hb(),s.lc(976," field, the "),s.Ib(977,"code"),s.lc(978,"rootValue"),s.Hb(),s.lc(979," passed from the server configuration."),s.Hb(),s.Ib(980,"li"),s.Ib(981,"code"),s.lc(982,"context"),s.Hb(),s.lc(983,": an object shared by all resolvers in a particular query; typically used to contain per-request state."),s.Hb(),s.Ib(984,"li"),s.Ib(985,"code"),s.lc(986,"info"),s.Hb(),s.lc(987,": an object that contains information about the execution state of the query."),s.Hb(),s.Ib(988,"li"),s.Ib(989,"code"),s.lc(990,"args"),s.Hb(),s.lc(991,": an object with the arguments passed into the field in the query."),s.Hb(),s.Hb(),s.Ib(992,"p"),s.Gb(993,"app-banner-shop"),s.Hb(),s.Ib(994,"h4",45),s.Ib(995,"span"),s.lc(996,"Module"),s.Hb(),s.Hb(),s.Ib(997,"p"),s.lc(998,"Once we're done with the above steps, we have declaratively specified all the information needed by the "),s.Ib(999,"code"),s.lc(1e3,"GraphQLModule"),s.Hb(),s.lc(1001," to generate a resolver map. The "),s.Ib(1002,"code"),s.lc(1003,"GraphQLModule"),s.Hb(),s.lc(1004," uses reflection to introspect the meta data provided via the decorators, and transforms classes into the correct resolver map automatically."),s.Hb(),s.Ib(1005,"p"),s.lc(1006,"The only other thing you need to take care of is to "),s.Ib(1007,"strong"),s.lc(1008,"provide"),s.Hb(),s.lc(1009," (i.e., list as a "),s.Ib(1010,"code"),s.lc(1011,"provider"),s.Hb(),s.lc(1012," in some module) the resolver class(es) ("),s.Ib(1013,"code"),s.lc(1014,"AuthorsResolver"),s.Hb(),s.lc(1015,"), and importing the module ("),s.Ib(1016,"code"),s.lc(1017,"AuthorsModule"),s.Hb(),s.lc(1018,") somewhere, so Nest will be able to utilize it."),s.Hb(),s.Ib(1019,"p"),s.lc(1020,"For example, we can do this in an "),s.Ib(1021,"code"),s.lc(1022,"AuthorsModule"),s.Hb(),s.lc(1023,", which can also provide other services needed in this context. Be sure to import "),s.Ib(1024,"code"),s.lc(1025,"AuthorsModule"),s.Hb(),s.lc(1026," somewhere (e.g., in the root module, or some other module imported by the root module)."),s.Hb(),s.Ib(1027,"span",10),s.lc(1028),s.Ub(1029,"extension"),s.Gb(1030,"app-tabs",null,46),s.Hb(),s.Ib(1032,"pre"),s.Ib(1033,"code",12),s.lc(1034,"\n@Module({\n  imports: [PostsModule],\n  providers: [AuthorsService, AuthorsResolver],\n})\nexport class AuthorsModule {}"),s.Hb(),s.Hb(),s.Ib(1035,"blockquote",13),s.Ib(1036,"strong"),s.lc(1037,"Hint"),s.Hb(),s.lc(1038," It is helpful to organize your code by your so-called "),s.Ib(1039,"strong"),s.lc(1040,"domain model"),s.Hb(),s.lc(1041," (similar to the way you would organize entry points in a REST API). In this approach, keep your models ("),s.Ib(1042,"code"),s.lc(1043,"ObjectType"),s.Hb(),s.lc(1044," classes), resolvers and services together within a Nest module representing the domain model. Keep all of these components in a single folder per module. When you do this, and use the "),s.Ib(1045,"a",47),s.lc(1046,"Nest CLI"),s.Hb(),s.lc(1047," to generate each element, Nest will wire all of these parts together (locating files in appropriate folders, generating entries in "),s.Ib(1048,"code"),s.lc(1049,"provider"),s.Hb(),s.lc(1050," and "),s.Ib(1051,"code"),s.lc(1052,"imports"),s.Hb(),s.lc(1053," arrays, etc.) automatically for you.\n"),s.Hb(),s.Hb()}if(2&e){const e=s.dc(51),t=s.dc(215),o=s.dc(228),n=s.dc(247),a=s.dc(381),r=s.dc(559),c=s.dc(736),l=s.dc(847),i=s.dc(872),b=s.dc(1031);s.vb(48),s.nc(" ",s.Vb(49,14,"authors/models/author.model",e.isJsActive),"\n"),s.vb(114),s.oc("@ObjectType(","{"," description: 'Author model' ","}",")"),s.vb(50),s.nc(" ",s.Vb(213,17,"posts/models/post.model",t.isJsActive),"\n"),s.vb(13),s.nc(" ",s.Vb(226,20,"schema.gql",o.isJsActive),"\n"),s.vb(19),s.nc(" ",s.Vb(245,23,"authors/authors.resolver",n.isJsActive),"\n"),s.vb(134),s.nc(" ",s.Vb(379,26,"authors/authors.resolver",a.isJsActive),"\n"),s.vb(24),s.oc("","{","name: 'author'","}",""),s.vb(154),s.nc(" ",s.Vb(557,29,"authors/dto/get-author.args",r.isJsActive),"\n"),s.vb(177),s.nc(" ",s.Vb(734,32,"authors/authors.resolver",c.isJsActive),"\n"),s.vb(111),s.nc(" ",s.Vb(845,35,"authors/authors.resolver.ts",l.isJsActive),"\n"),s.vb(25),s.nc(" ",s.Vb(870,38,"graphql.ts",i.isJsActive),"\n"),s.vb(159),s.nc(" ",s.Vb(1029,41,"authors/authors.module",b.isJsActive),"\n")}},directives:[l.a,i.a,a.f,C.a],pipes:[b.a],encapsulation:2,changeDetection:0}),e})();const E=s.Kb(D);let N=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return M(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-scalars"]],features:[s.tb],decls:177,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/scalars.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","scalars"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#scalar-types"],["appAnchor","","id","code-first"],[1,"language-typescript"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-tools/scalars.html"],[1,"language-bash"],[1,"language-graphql"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Scalars"),s.Hb(),s.Ib(7,"p"),s.lc(8,"A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That's where the scalar types come in: they represent the leaves of the query (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,"). GraphQL includes the following default types: "),s.Ib(12,"code"),s.lc(13,"Int"),s.Hb(),s.lc(14,", "),s.Ib(15,"code"),s.lc(16,"Float"),s.Hb(),s.lc(17,", "),s.Ib(18,"code"),s.lc(19,"String"),s.Hb(),s.lc(20,", "),s.Ib(21,"code"),s.lc(22,"Boolean"),s.Hb(),s.lc(23," and "),s.Ib(24,"code"),s.lc(25,"ID"),s.Hb(),s.lc(26,". In addition to these built-in types, you may need to support custom atomic data types (e.g., "),s.Ib(27,"code"),s.lc(28,"Date"),s.Hb(),s.lc(29,")."),s.Hb(),s.Ib(30,"h4",7),s.Ib(31,"span"),s.lc(32,"Code first"),s.Hb(),s.Hb(),s.Ib(33,"p"),s.lc(34,"The code-first approach ships with five scalars in which three of them are simple aliases for the existing GraphQL types."),s.Hb(),s.Ib(35,"ul"),s.Ib(36,"li"),s.Ib(37,"code"),s.lc(38,"ID"),s.Hb(),s.lc(39," (alias for "),s.Ib(40,"code"),s.lc(41,"GraphQLID"),s.Hb(),s.lc(42,") - represents a unique identifier, often used to refetch an object or as the key for a cache"),s.Hb(),s.Ib(43,"li"),s.Ib(44,"code"),s.lc(45,"Int"),s.Hb(),s.lc(46," (alias for "),s.Ib(47,"code"),s.lc(48,"GraphQLInt"),s.Hb(),s.lc(49,") - a signed 32\u2010bit integer"),s.Hb(),s.Ib(50,"li"),s.Ib(51,"code"),s.lc(52,"Float"),s.Hb(),s.lc(53," (alias for "),s.Ib(54,"code"),s.lc(55,"GraphQLFloat"),s.Hb(),s.lc(56,") - a signed double-precision floating-point value"),s.Hb(),s.Ib(57,"li"),s.Ib(58,"code"),s.lc(59,"GraphQLISODateTime"),s.Hb(),s.lc(60," - a date-time string at UTC (used by default to represent "),s.Ib(61,"code"),s.lc(62,"Date"),s.Hb(),s.lc(63," type)"),s.Hb(),s.Ib(64,"li"),s.Ib(65,"code"),s.lc(66,"GraphQLTimestamp"),s.Hb(),s.lc(67," - a numeric string which represents time and date as number of milliseconds from start of UNIX epoch"),s.Hb(),s.Hb(),s.Ib(68,"p"),s.lc(69,"The "),s.Ib(70,"code"),s.lc(71,"GraphQLISODateTime"),s.Hb(),s.lc(72," (e.g. "),s.Ib(73,"code"),s.lc(74,"2019-12-03T09:54:33Z"),s.Hb(),s.lc(75,") is used by default to represent the "),s.Ib(76,"code"),s.lc(77,"Date"),s.Hb(),s.lc(78," type. To use the "),s.Ib(79,"code"),s.lc(80,"GraphQLTimestamp"),s.Hb(),s.lc(81," instead, set the "),s.Ib(82,"code"),s.lc(83,"dateScalarMode"),s.Hb(),s.lc(84," of the "),s.Ib(85,"code"),s.lc(86,"buildSchemaOptions"),s.Hb(),s.lc(87," object to "),s.Ib(88,"code"),s.lc(89,"'timestamp'"),s.Hb(),s.lc(90," as follows:"),s.Hb(),s.Ib(91,"pre"),s.Ib(92,"code",8),s.lc(93,"\nGraphQLModule.forRoot({\n  buildSchemaOptions: {\n    dateScalarMode: 'timestamp',\n  }\n}),"),s.Hb(),s.Hb(),s.Ib(94,"p"),s.lc(95,"In addition, you can create custom scalars. For example, to create a "),s.Ib(96,"code"),s.lc(97,"Date"),s.Hb(),s.lc(98," scalar, simply create a new class."),s.Hb(),s.Ib(99,"pre"),s.Ib(100,"code",8),s.lc(101,"\nimport { Scalar, CustomScalar } from '@nestjs/graphql';\nimport { Kind, ValueNode } from 'graphql';\n\n@Scalar('Date', type => Date)\nexport class DateScalar implements CustomScalar<number, Date> {\n  description = 'Date custom scalar type';\n\n  parseValue(value: number): Date {\n    return new Date(value); // value from the client\n  }\n\n  serialize(value: Date): number {\n    return value.getTime(); // value sent to the client\n  }\n\n  parseLiteral(ast: ValueNode): Date {\n    if (ast.kind === Kind.INT) {\n      return new Date(ast.value);\n    }\n    return null;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(102,"p"),s.lc(103,"With this in place, register "),s.Ib(104,"code"),s.lc(105,"DateScalar"),s.Hb(),s.lc(106," as a provider."),s.Hb(),s.Ib(107,"pre"),s.Ib(108,"code",8),s.lc(109,"\n@Module({\n  providers: [DateScalar],\n})\nexport class CommonModule {}"),s.Hb(),s.Hb(),s.Ib(110,"p"),s.lc(111,"Now we can use the "),s.Ib(112,"code"),s.lc(113,"Date"),s.Hb(),s.lc(114," type in our classes."),s.Hb(),s.Ib(115,"pre"),s.Ib(116,"code",8),s.lc(117,"\n@Field()\ncreationDate: Date;"),s.Hb(),s.Hb(),s.Ib(118,"h4",9),s.Ib(119,"span"),s.lc(120,"Schema first"),s.Hb(),s.Hb(),s.Ib(121,"p"),s.lc(122,"To define a custom scalar (read more about scalars "),s.Ib(123,"a",10),s.lc(124,"here"),s.Hb(),s.lc(125,"), create a type definition and a dedicated resolver. Here (as in the official documentation), we\u2019ll use the "),s.Ib(126,"code"),s.lc(127,"graphql-type-json"),s.Hb(),s.lc(128," package for demonstration purposes. This npm package defines a "),s.Ib(129,"code"),s.lc(130,"JSON"),s.Hb(),s.lc(131," GraphQL scalar type."),s.Hb(),s.Ib(132,"p"),s.lc(133,"Start by installing the package:"),s.Hb(),s.Ib(134,"pre"),s.Ib(135,"code",11),s.lc(136,"\n$ npm i --save graphql-type-json"),s.Hb(),s.Hb(),s.Ib(137,"p"),s.lc(138,"Once the package is installed, we pass a custom resolver to the "),s.Ib(139,"code"),s.lc(140,"forRoot()"),s.Hb(),s.lc(141," method:"),s.Hb(),s.Ib(142,"pre"),s.Ib(143,"code",8),s.lc(144,"\nimport GraphQLJSON from 'graphql-type-json';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      typePaths: ['./**/*.graphql'],\n      resolvers: { JSON: GraphQLJSON },\n    }),\n  ],\n})\nexport class ApplicationModule {}"),s.Hb(),s.Hb(),s.Ib(145,"p"),s.lc(146,"Now we can use the "),s.Ib(147,"code"),s.lc(148,"JSON"),s.Hb(),s.lc(149," scalar in our type definitions:"),s.Hb(),s.Ib(150,"pre"),s.Ib(151,"code",12),s.lc(152,"\nscalar JSON\n\ntype Foo {\n  field: JSON\n}"),s.Hb(),s.Hb(),s.Ib(153,"p"),s.lc(154,"Another method to define a scalar type is to create a simple class. Assume we want to enhance our schema with the "),s.Ib(155,"code"),s.lc(156,"Date"),s.Hb(),s.lc(157," type."),s.Hb(),s.Ib(158,"pre"),s.Ib(159,"code",8),s.lc(160,"\nimport { Scalar, CustomScalar } from '@nestjs/graphql';\nimport { Kind, ValueNode } from 'graphql';\n\n@Scalar('Date')\nexport class DateScalar implements CustomScalar<number, Date> {\n  description = 'Date custom scalar type';\n\n  parseValue(value: number): Date {\n    return new Date(value); // value from the client\n  }\n\n  serialize(value: Date): number {\n    return value.getTime(); // value sent to the client\n  }\n\n  parseLiteral(ast: ValueNode): Date {\n    if (ast.kind === Kind.INT) {\n      return new Date(ast.value);\n    }\n    return null;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(161,"p"),s.lc(162,"With this in place, register "),s.Ib(163,"code"),s.lc(164,"DateScalar"),s.Hb(),s.lc(165," as a provider."),s.Hb(),s.Ib(166,"pre"),s.Ib(167,"code",8),s.lc(168,"\n@Module({\n  providers: [DateScalar],\n})\nexport class CommonModule {}"),s.Hb(),s.Hb(),s.Ib(169,"p"),s.lc(170,"Now we can use the "),s.Ib(171,"code"),s.lc(172,"Date"),s.Hb(),s.lc(173," scalar in type definitions."),s.Hb(),s.Ib(174,"pre"),s.Ib(175,"code",12),s.lc(176,"\nscalar Date"),s.Hb(),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const M=s.Kb(N);let U=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return O(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-schema-generator"]],features:[s.tb],decls:70,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/schema-generator.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","generating-sdl"],[1,"warning"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","usage"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Generating SDL"),s.Hb(),s.Ib(7,"blockquote",6),s.Ib(8,"strong"),s.lc(9,"Warning"),s.Hb(),s.lc(10," This chapter applies only to the code first approach.\n"),s.Hb(),s.Ib(11,"p"),s.lc(12,"To manually generate a GraphQL SDL schema (i.e., without running an application, connecting to the database, hooking up resolvers, etc.), use the "),s.Ib(13,"code"),s.lc(14,"GraphQLSchemaBuilderModule"),s.Hb(),s.lc(15,"."),s.Hb(),s.Ib(16,"pre"),s.Ib(17,"code",7),s.lc(18,"\nasync function generateSchema() {\n  const app = await NestFactory.create(GraphQLSchemaBuilderModule);\n  await app.init();\n\n  const gqlSchemaFactory = app.get(GraphQLSchemaFactory);\n  const schema = await gqlSchemaFactory.create([RecipesResolver]);\n  console.log(printSchema(schema));\n}"),s.Hb(),s.Hb(),s.Ib(19,"blockquote",8),s.Ib(20,"strong"),s.lc(21,"Hint"),s.Hb(),s.lc(22," The "),s.Ib(23,"code"),s.lc(24,"GraphQLSchemaBuilderModule"),s.Hb(),s.lc(25," and "),s.Ib(26,"code"),s.lc(27,"GraphQLSchemaFactory"),s.Hb(),s.lc(28," are imported from the "),s.Ib(29,"code"),s.lc(30,"@nestjs/graphql"),s.Hb(),s.lc(31," package. The "),s.Ib(32,"code"),s.lc(33,"printSchema"),s.Hb(),s.lc(34," function is imported from the "),s.Ib(35,"code"),s.lc(36,"graphql"),s.Hb(),s.lc(37," package.\n"),s.Hb(),s.Ib(38,"h4",9),s.Ib(39,"span"),s.lc(40,"Usage"),s.Hb(),s.Hb(),s.Ib(41,"p"),s.lc(42,"The "),s.Ib(43,"code"),s.lc(44,"gqlSchemaFactory.create()"),s.Hb(),s.lc(45," method takes an array of resolver class references. For example:"),s.Hb(),s.Ib(46,"pre"),s.Ib(47,"code",7),s.lc(48,"\nconst schema = await gqlSchemaFactory.create([\n  RecipesResolver,\n  AuthorsResolver,\n  PostsResolvers,\n]);"),s.Hb(),s.Hb(),s.Ib(49,"p"),s.lc(50,"It also takes a second optional argument with an array of scalar classes:"),s.Hb(),s.Ib(51,"pre"),s.Ib(52,"code",7),s.lc(53,"\nconst schema = await gqlSchemaFactory.create(\n  [RecipesResolver, AuthorsResolver, PostsResolvers],\n  [DurationScalar, DateScalar],\n);"),s.Hb(),s.Hb(),s.Ib(54,"p"),s.lc(55,"Lastly, you can pass an options object:"),s.Hb(),s.Ib(56,"pre"),s.Ib(57,"code",7),s.lc(58,"\nconst schema = await gqlSchemaFactory.create([RecipesResolver], {\n  skipCheck: true,\n  orphanedTypes: [],\n});"),s.Hb(),s.Hb(),s.Ib(59,"ul"),s.Ib(60,"li"),s.Ib(61,"code"),s.lc(62,"skipCheck"),s.Hb(),s.lc(63,": ignore schema validation; boolean, defaults to "),s.Ib(64,"code"),s.lc(65,"false"),s.Hb(),s.Hb(),s.Ib(66,"li"),s.Ib(67,"code"),s.lc(68,"orphanedTypes"),s.Hb(),s.lc(69,": list of classes that are not explicitly referenced (not part of the object graph) to be generated. Normally, if a class is declared but isn't otherwise referenced in the graph, it's omitted. The property value is an array of class references."),s.Hb(),s.Hb(),s.Hb())},directives:[l.a],encapsulation:2,changeDetection:0}),e})();const O=s.Kb(U);let _=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return B(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-subscriptions"]],features:[s.tb],decls:308,vars:8,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/subscriptions.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","subscriptions"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/react/data/subscriptions"],["appAnchor","","id","enable-subscriptions"],[1,"language-typescript"],["appAnchor","","id","code-first"],[1,"info"],[1,"warning"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-subscriptions/setup.html"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/graphql-subscriptions#getting-started-with-your-first-subscription"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/graphql-subscriptions#pubsub-implementations"],[1,"language-graphql"],["appAnchor","","id","publishing"],[1,"filename"],["app4f9a1d504b397f272de79e8b7c80fc4e11da1ab3",""],["appAnchor","","id","filtering-subscriptions"],["appAnchor","","id","mutating-subscription-payloads"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/blob/master/sample/12-graphql-schema-first"],["appAnchor","","id","pubsub"],["routerLink","/fundamentals/custom-providers"],["appAnchor","","id","customize-subscriptions-server"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/v2/api/apollo-server.html#constructor-options-lt-ApolloServer-gt"]],template:function(e,t){if(1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Subscriptions"),s.Hb(),s.Ib(7,"p"),s.lc(8,"In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called "),s.Ib(9,"code"),s.lc(10,"subscription"),s.Hb(),s.lc(11,". GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a channel is opened and a result is sent to the client every time a particular event happens on the server."),s.Hb(),s.Ib(12,"p"),s.lc(13,"A common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on (read more "),s.Ib(14,"a",6),s.lc(15,"here"),s.Hb(),s.lc(16,")."),s.Hb(),s.Ib(17,"h4",7),s.Ib(18,"span"),s.lc(19,"Enable subscriptions"),s.Hb(),s.Hb(),s.Ib(20,"p"),s.lc(21,"To enable subscriptions, set the "),s.Ib(22,"code"),s.lc(23,"installSubscriptionHandlers"),s.Hb(),s.lc(24," property to "),s.Ib(25,"code"),s.lc(26,"true"),s.Hb(),s.lc(27,"."),s.Hb(),s.Ib(28,"pre"),s.Ib(29,"code",8),s.lc(30,"\nGraphQLModule.forRoot({\n  installSubscriptionHandlers: true,\n}),"),s.Hb(),s.Hb(),s.Ib(31,"h4",9),s.Ib(32,"span"),s.lc(33,"Code first"),s.Hb(),s.Hb(),s.Ib(34,"p"),s.lc(35,"To create a subscription using the code first approach, we use the "),s.Ib(36,"code"),s.lc(37,"@Subscription()"),s.Hb(),s.lc(38," decorator and the "),s.Ib(39,"code"),s.lc(40,"PubSub"),s.Hb(),s.lc(41," class from the "),s.Ib(42,"code"),s.lc(43,"graphql-subscriptions"),s.Hb(),s.lc(44," package, which provides a simple "),s.Ib(45,"strong"),s.lc(46,"publish/subscribe API"),s.Hb(),s.lc(47,"."),s.Hb(),s.Ib(48,"p"),s.lc(49,"The following subscription handler takes care of "),s.Ib(50,"strong"),s.lc(51,"subscribing"),s.Hb(),s.lc(52," to an event by calling "),s.Ib(53,"code"),s.lc(54,"PubSub#asyncIterator"),s.Hb(),s.lc(55,". This method takes a single argument, the "),s.Ib(56,"code"),s.lc(57,"triggerName"),s.Hb(),s.lc(58,", which corresponds to an event topic name."),s.Hb(),s.Ib(59,"pre"),s.Ib(60,"code",8),s.lc(61,"\nconst pubSub = new PubSub();\n\n@Resolver(of => Author)\nexport class AuthorResolver {\n  // ...\n  @Subscription(returns => Comment)\n  commentAdded() {\n    return pubSub.asyncIterator('commentAdded');\n  }\n}"),s.Hb(),s.Hb(),s.Ib(62,"blockquote",10),s.Ib(63,"strong"),s.lc(64,"Hint"),s.Hb(),s.lc(65," All decorators are exported from the "),s.Ib(66,"code"),s.lc(67,"@nestjs/graphql"),s.Hb(),s.lc(68," package, while the "),s.Ib(69,"code"),s.lc(70,"PubSub"),s.Hb(),s.lc(71," class is exported from the "),s.Ib(72,"code"),s.lc(73,"graphql-subscriptions"),s.Hb(),s.lc(74," package.\n"),s.Hb(),s.Ib(75,"blockquote",11),s.Ib(76,"strong"),s.lc(77,"Note"),s.Hb(),s.Ib(78,"code"),s.lc(79,"PubSub"),s.Hb(),s.lc(80," is a class that exposes a simple "),s.Ib(81,"code"),s.lc(82,"publish"),s.Hb(),s.lc(83," and "),s.Ib(84,"code"),s.lc(85,"subscribe API"),s.Hb(),s.lc(86,". Read more about it "),s.Ib(87,"a",12),s.lc(88,"here"),s.Hb(),s.lc(89,". Note that the Apollo docs warn that the default implementation is not suitable for production (read more "),s.Ib(90,"a",13),s.lc(91,"here"),s.Hb(),s.lc(92,"). Production apps should use a "),s.Ib(93,"code"),s.lc(94,"PubSub"),s.Hb(),s.lc(95," implementation backed by an external store (read more "),s.Ib(96,"a",14),s.lc(97,"here"),s.Hb(),s.lc(98,").\n"),s.Hb(),s.Ib(99,"p"),s.lc(100,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(101,"pre"),s.Ib(102,"code",15),s.lc(103,"\ntype Subscription {\n  commentAdded(): Comment!\n}"),s.Hb(),s.Hb(),s.Ib(104,"p"),s.lc(105,"Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., "),s.Ib(106,"code"),s.lc(107,"commentAdded"),s.Hb(),s.lc(108," above), or is provided explicitly by passing an option with the key "),s.Ib(109,"code"),s.lc(110,"name"),s.Hb(),s.lc(111," as the second argument to the "),s.Ib(112,"code"),s.lc(113,"@Subscription()"),s.Hb(),s.lc(114," decorator, as shown below."),s.Hb(),s.Ib(115,"pre"),s.Ib(116,"code",8),s.lc(117,"\n  @Subscription(returns => Comment, {\n    name: 'commentAdded',\n  })\n  addCommentHandler() {\n    return pubSub.asyncIterator('commentAdded');\n  }"),s.Hb(),s.Hb(),s.Ib(118,"p"),s.lc(119,"This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription."),s.Hb(),s.Ib(120,"h4",16),s.Ib(121,"span"),s.lc(122,"Publishing"),s.Hb(),s.Hb(),s.Ib(123,"p"),s.lc(124,"Now, to publish the event, we use the "),s.Ib(125,"code"),s.lc(126,"PubSub#publish"),s.Hb(),s.lc(127," method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:"),s.Hb(),s.Ib(128,"span",17),s.lc(129),s.Ub(130,"extension"),s.Gb(131,"app-tabs",null,18),s.Hb(),s.Ib(133,"pre"),s.Ib(134,"code",8),s.lc(135,"\n@Mutation(returns => Post)\nasync addComment(\n  @Args('postId', { type: () => Int }) postId: number,\n  @Args('comment', { type: () => Comment }) comment: CommentInput,\n) {\n  const newComment = this.commentsService.addComment({ id: postId, comment });\n  pubSub.publish('commentAdded', { commentAdded: newComment });\n  return newComment;\n}"),s.Hb(),s.Hb(),s.Ib(136,"p"),s.lc(137,"The "),s.Ib(138,"code"),s.lc(139,"PubSub#publish"),s.Hb(),s.lc(140," method takes a "),s.Ib(141,"code"),s.lc(142,"triggerName"),s.Hb(),s.lc(143," (again, think of this as an event topic name) as the first parameter, and an event payload as the second parameter. As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our "),s.Ib(144,"code"),s.lc(145,"commentAdded"),s.Hb(),s.lc(146," subscription:"),s.Hb(),s.Ib(147,"pre"),s.Ib(148,"code",15),s.lc(149,"\ntype Subscription {\n  commentAdded(): Comment!\n}"),s.Hb(),s.Hb(),s.Ib(150,"p"),s.lc(151,"This tells us that the subscription must return an object with a top-level property name of "),s.Ib(152,"code"),s.lc(153,"commentAdded"),s.Hb(),s.lc(154," that has a value which is a "),s.Ib(155,"code"),s.lc(156,"Comment"),s.Hb(),s.lc(157," object. The important point to note is that the shape of the event payload emitted by the "),s.Ib(158,"code"),s.lc(159,"PubSub#publish"),s.Hb(),s.lc(160," method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the "),s.Ib(161,"code"),s.lc(162),s.Hb(),s.lc(163," statement publishes a "),s.Ib(164,"code"),s.lc(165,"commentAdded"),s.Hb(),s.lc(166," event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase."),s.Hb(),s.Ib(167,"h4",19),s.Ib(168,"span"),s.lc(169,"Filtering subscriptions"),s.Hb(),s.Hb(),s.Ib(170,"p"),s.lc(171,"To filter out specific events, set the "),s.Ib(172,"code"),s.lc(173,"filter"),s.Hb(),s.lc(174," property to a filter function. This function acts similar to the function passed to an array "),s.Ib(175,"code"),s.lc(176,"filter"),s.Hb(),s.lc(177,". It takes two arguments: "),s.Ib(178,"code"),s.lc(179,"payload"),s.Hb(),s.lc(180," containing the event payload (as sent by the event publisher), and "),s.Ib(181,"code"),s.lc(182,"variables"),s.Hb(),s.lc(183," taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners."),s.Hb(),s.Ib(184,"pre"),s.Ib(185,"code",8),s.lc(186,"\n@Subscription(returns => Comment, {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Args('title') title: string) {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(187,"h4",20),s.Ib(188,"span"),s.lc(189,"Mutating subscription payloads"),s.Hb(),s.Hb(),s.Ib(190,"p"),s.lc(191,"To mutate the published event payload, set the "),s.Ib(192,"code"),s.lc(193,"resolve"),s.Hb(),s.lc(194," property to a function. The function receives the event payload (as sent by the event publisher) and returns the appropriate value."),s.Hb(),s.Ib(195,"pre"),s.Ib(196,"code",8),s.lc(197,"\n@Subscription(returns => Comment, {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(198,"blockquote",11),s.Ib(199,"strong"),s.lc(200,"Note"),s.Hb(),s.lc(201," If you use the "),s.Ib(202,"code"),s.lc(203,"resolve"),s.Hb(),s.lc(204," option, you should return the unwrapped payload (e.g., with our example, return a "),s.Ib(205,"code"),s.lc(206,"newComment"),s.Hb(),s.lc(207," object directly, not a "),s.Ib(208,"code"),s.lc(209),s.Hb(),s.lc(210," object).\n"),s.Hb(),s.Ib(211,"p"),s.lc(212,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction."),s.Hb(),s.Ib(213,"pre"),s.Ib(214,"code",8),s.lc(215,'\n@Subscription(returns => Comment, {\n  resolve(this: AuthorResolver, value) {\n    // "this" refers to an instance of "AuthorResolver"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator(\'commentAdded\');\n}'),s.Hb(),s.Hb(),s.Ib(216,"p"),s.lc(217,"The same construction works with filters:"),s.Hb(),s.Ib(218,"pre"),s.Ib(219,"code",8),s.lc(220,'\n@Subscription(returns => Comment, {\n  filter(this: AuthorResolver, payload, variables) {\n    // "this" refers to an instance of "AuthorResolver"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator(\'commentAdded\');\n}'),s.Hb(),s.Hb(),s.Ib(221,"h4",21),s.Ib(222,"span"),s.lc(223,"Schema first"),s.Hb(),s.Hb(),s.Ib(224,"p"),s.lc(225,"To create an equivalent subscription in Nest, we'll make use of the "),s.Ib(226,"code"),s.lc(227,"@Subscription()"),s.Hb(),s.lc(228," decorator."),s.Hb(),s.Ib(229,"pre"),s.Ib(230,"code",8),s.lc(231,"\nconst pubSub = new PubSub();\n\n@Resolver('Author')\nexport class AuthorResolver {\n  // ...\n  @Subscription()\n  commentAdded() {\n    return pubSub.asyncIterator('commentAdded');\n  }\n}"),s.Hb(),s.Hb(),s.Ib(232,"p"),s.lc(233,"To filter out specific events based on context and arguments, set the "),s.Ib(234,"code"),s.lc(235,"filter"),s.Hb(),s.lc(236," property."),s.Hb(),s.Ib(237,"pre"),s.Ib(238,"code",8),s.lc(239,"\n@Subscription('commentAdded', {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(240,"p"),s.lc(241,"To mutate the published payload, we can use a "),s.Ib(242,"code"),s.lc(243,"resolve"),s.Hb(),s.lc(244," function."),s.Hb(),s.Ib(245,"pre"),s.Ib(246,"code",8),s.lc(247,"\n@Subscription('commentAdded', {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(248,"p"),s.lc(249,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:"),s.Hb(),s.Ib(250,"pre"),s.Ib(251,"code",8),s.lc(252,"\n@Subscription('commentAdded', {\n  resolve(this: AuthorResolver, value) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(253,"p"),s.lc(254,"The same construction works with filters:"),s.Hb(),s.Ib(255,"pre"),s.Ib(256,"code",8),s.lc(257,"\n@Subscription('commentAdded', {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}"),s.Hb(),s.Hb(),s.Ib(258,"p"),s.lc(259,"The last step is to update the type definitions file."),s.Hb(),s.Ib(260,"pre"),s.Ib(261,"code",15),s.lc(262,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Comment {\n  id: String\n  content: String\n}\n\ntype Subscription {\n  commentAdded(title: String!): Comment\n}"),s.Hb(),s.Hb(),s.Ib(263,"p"),s.lc(264,"With this, we've created a single "),s.Ib(265,"code"),s.lc(266,"commentAdded(title: String!): Comment"),s.Hb(),s.lc(267," subscription. You can find a full sample implementation "),s.Ib(268,"a",22),s.lc(269,"here"),s.Hb(),s.lc(270,"."),s.Hb(),s.Ib(271,"h4",23),s.Ib(272,"span"),s.lc(273,"PubSub"),s.Hb(),s.Hb(),s.Ib(274,"p"),s.lc(275,"We instantiated a local "),s.Ib(276,"code"),s.lc(277,"PubSub"),s.Hb(),s.lc(278," instance above. The preferred approach is to define "),s.Ib(279,"code"),s.lc(280,"PubSub"),s.Hb(),s.lc(281," as a "),s.Ib(282,"a",24),s.lc(283,"provider"),s.Hb(),s.lc(284," and inject it through the constructor (using the "),s.Ib(285,"code"),s.lc(286,"@Inject()"),s.Hb(),s.lc(287," decorator). This allows us to re-use the instance across the whole application. For example, define a provider as follows, then inject "),s.Ib(288,"code"),s.lc(289,"'PUB_SUB'"),s.Hb(),s.lc(290," where needed."),s.Hb(),s.Ib(291,"pre"),s.Ib(292,"code",8),s.lc(293,"\n{\n  provide: 'PUB_SUB',\n  useValue: new PubSub(),\n}"),s.Hb(),s.Hb(),s.Ib(294,"h4",25),s.Ib(295,"span"),s.lc(296,"Customize subscriptions server"),s.Hb(),s.Hb(),s.Ib(297,"p"),s.lc(298,"To customize the subscriptions server (e.g., change the listener port), use the "),s.Ib(299,"code"),s.lc(300,"subscriptions"),s.Hb(),s.lc(301," options property (read "),s.Ib(302,"a",26),s.lc(303,"more"),s.Hb(),s.lc(304,")."),s.Hb(),s.Ib(305,"pre"),s.Ib(306,"code",8),s.lc(307,"\nGraphQLModule.forRoot({\n  installSubscriptionHandlers: true,\n  subscriptions: {\n    keepAlive: 5000,\n  }\n}),"),s.Hb(),s.Hb(),s.Hb()),2&e){const e=s.dc(132);s.vb(129),s.nc(" ",s.Vb(130,5,"posts/posts.resolver",e.isJsActive),"\n"),s.vb(33),s.oc("pubSub.publish('commentAdded', ","{"," commentAdded: newComment ","}",")"),s.vb(47),s.oc("","{"," commentAdded: newComment ","}","")}},directives:[l.a,i.a,a.f],pipes:[b.a],encapsulation:2,changeDetection:0}),e})();const B=s.Kb(_);let W=(()=>{class e extends c.a{}return e.\u0275fac=function(t){return z(t||e)},e.\u0275cmp=s.zb({type:e,selectors:[["app-unions"]],features:[s.tb],decls:117,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/unions.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","unions"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#union-types"],["appAnchor","","id","code-first"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#union-type"],[1,"language-typescript"],[1,"language-graphql"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"],[1,"info"]],template:function(e,t){1&e&&(s.Ib(0,"div",0,1),s.Ib(2,"div",2),s.Ib(3,"a",3),s.Gb(4,"i",4),s.Hb(),s.Hb(),s.Ib(5,"h3",5),s.lc(6,"Unions"),s.Hb(),s.Ib(7,"p"),s.lc(8,"Union types are very similar to interfaces, but they don't get to specify any common fields between the types (read more "),s.Ib(9,"a",6),s.lc(10,"here"),s.Hb(),s.lc(11,"). Unions are useful for returning disjoint data types from a single field."),s.Hb(),s.Ib(12,"h4",7),s.Ib(13,"span"),s.lc(14,"Code first"),s.Hb(),s.Hb(),s.Ib(15,"p"),s.lc(16,"To define a GraphQL union type, we must define classes that this union will be composed of. Following the "),s.Ib(17,"a",8),s.lc(18,"example"),s.Hb(),s.lc(19," from the Apollo documentation, we'll create two classes. First, "),s.Ib(20,"code"),s.lc(21,"Book"),s.Hb(),s.lc(22,":"),s.Hb(),s.Ib(23,"pre"),s.Ib(24,"code",9),s.lc(25,"\nimport { Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Book {\n  @Field()\n  title: string;\n}"),s.Hb(),s.Hb(),s.Ib(26,"p"),s.lc(27,"And then "),s.Ib(28,"code"),s.lc(29,"Author"),s.Hb(),s.lc(30,":"),s.Hb(),s.Ib(31,"pre"),s.Ib(32,"code",9),s.lc(33,"\nimport { Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Author {\n  @Field()\n  name: string;\n}"),s.Hb(),s.Hb(),s.Ib(34,"p"),s.lc(35,"With this in place, register the "),s.Ib(36,"code"),s.lc(37,"Result"),s.Hb(),s.lc(38," union using the "),s.Ib(39,"code"),s.lc(40,"createUnionType"),s.Hb(),s.lc(41," function exported from the "),s.Ib(42,"code"),s.lc(43,"@nestjs/graphql"),s.Hb(),s.lc(44," package:"),s.Hb(),s.Ib(45,"pre"),s.Ib(46,"code",9),s.lc(47,"\nexport const ResultUnion = createUnionType({\n  name: 'Result',\n  types: () => [Author, Book],\n});"),s.Hb(),s.Hb(),s.Ib(48,"p"),s.lc(49,"Now, we can reference the "),s.Ib(50,"code"),s.lc(51,"ResultUnion"),s.Hb(),s.lc(52," in our query:"),s.Hb(),s.Ib(53,"pre"),s.Ib(54,"code",9),s.lc(55,"\n@Query(returns => [ResultUnion])\nsearch(): Array<typeof ResultUnion> {\n  return [new Author(), new Book()];\n}"),s.Hb(),s.Hb(),s.Ib(56,"p"),s.lc(57,"This will result in generating the following part of the GraphQL schema in SDL:"),s.Hb(),s.Ib(58,"pre"),s.Ib(59,"code",10),s.lc(60,"\ntype Author {\n  name: String!\n}\n\ntype Book {\n  title: String!\n}\n\nunion ResultUnion = Author | Book\n\ntype Query {\n  search: [ResultUnion!]!\n}"),s.Hb(),s.Hb(),s.Ib(61,"p"),s.lc(62,"The default "),s.Ib(63,"code"),s.lc(64,"resolveType()"),s.Hb(),s.lc(65," function generated by the library will extract the type based on the value returned from the resolver method. That means returning class instances instead of literal JavaScript object is obligatory."),s.Hb(),s.Ib(66,"p"),s.lc(67,"To provide a customized "),s.Ib(68,"code"),s.lc(69,"resolveType()"),s.Hb(),s.lc(70," function, pass the "),s.Ib(71,"code"),s.lc(72,"resolveType"),s.Hb(),s.lc(73," property to the options object passed into the "),s.Ib(74,"code"),s.lc(75,"createUnionType()"),s.Hb(),s.lc(76," function, as follows:"),s.Hb(),s.Ib(77,"pre"),s.Ib(78,"code",9),s.lc(79,"\nexport const ResultUnion = createUnionType({\n  name: 'Result',\n  types: () => [Author, Book],\n  resolveType(value) {\n    if (value.name) {\n      return Author;\n    }\n    if (value.title) {\n      return Book;\n    }\n    return null;\n  },\n});"),s.Hb(),s.Hb(),s.Ib(80,"h4",11),s.Ib(81,"span"),s.lc(82,"Schema first"),s.Hb(),s.Hb(),s.Ib(83,"p"),s.lc(84,"To define a union in the schema first approach, simply create a GraphQL union with SDL."),s.Hb(),s.Ib(85,"pre"),s.Ib(86,"code",10),s.lc(87,"\ntype Author {\n  name: String!\n}\n\ntype Book {\n  title: String!\n}\n\nunion ResultUnion = Author | Book"),s.Hb(),s.Hb(),s.Ib(88,"p"),s.lc(89,"Then, you can use the typings generation feature (as shown in the "),s.Ib(90,"a",12),s.lc(91,"quick start"),s.Hb(),s.lc(92," chapter) to generate corresponding TypeScript definitions:"),s.Hb(),s.Ib(93,"pre"),s.Ib(94,"code",9),s.lc(95,"\nexport class Author {\n  name: string;\n}\n\nexport class Book {\n  title: string;\n}\n\nexport type ResultUnion = Author | Book;"),s.Hb(),s.Hb(),s.Ib(96,"p"),s.lc(97,"Unions require an extra "),s.Ib(98,"code"),s.lc(99,"__resolveType"),s.Hb(),s.lc(100," field in the resolver map to determine which type the union should resolve to. Let's create a "),s.Ib(101,"code"),s.lc(102,"ResultUnionResolver"),s.Hb(),s.lc(103," class and define the "),s.Ib(104,"code"),s.lc(105,"__resolveType"),s.Hb(),s.lc(106," method:"),s.Hb(),s.Ib(107,"pre"),s.Ib(108,"code",9),s.lc(109,"\n@Resolver('ResultUnion')\nexport class ResultUnionResolver {\n  @ResolveField()\n  __resolveType(value) {\n    if (value.name) {\n      return 'Author';\n    }\n    if (value.title) {\n      return 'Book';\n    }\n    return null;\n  }\n}"),s.Hb(),s.Hb(),s.Ib(110,"blockquote",13),s.Ib(111,"strong"),s.lc(112,"Hint"),s.Hb(),s.lc(113," All decorators are exported from the "),s.Ib(114,"code"),s.lc(115,"@nestjs/graphql"),s.Hb(),s.lc(116," package.\n"),s.Hb(),s.Hb())},directives:[l.a,a.f],encapsulation:2,changeDetection:0}),e})();const z=s.Kb(W),V=[{path:"quick-start",component:F,data:{title:"GraphQL + TypeScript"}},{path:"resolvers-map",redirectTo:"resolvers"},{path:"resolvers",component:D,data:{title:"GraphQL + TypeScript - Resolvers"}},{path:"mutations",component:L,data:{title:"GraphQL + TypeScript - Mutations"}},{path:"scalars",component:N,data:{title:"GraphQL + TypeScript - Scalars"}},{path:"subscriptions",component:_,data:{title:"GraphQL + TypeScript - Subscriptions"}},{path:"guards-interceptors",redirectTo:"other-features"},{path:"tooling",redirectTo:"other-features"},{path:"other-features",component:A,data:{title:"GraphQL + TypeScript - Other features"}},{path:"federation",component:v,data:{title:"GraphQL + TypeScript - Federation"}},{path:"directives",component:I,data:{title:"GraphQL + TypeScript - Directives"}},{path:"complexity",component:h,data:{title:"GraphQL + TypeScript - Complexity"}},{path:"extensions",component:f,data:{title:"GraphQL + TypeScript - Extensions"}},{path:"enums",component:H,data:{title:"GraphQL + TypeScript - Enums"}},{path:"unions",component:W,data:{title:"GraphQL + TypeScript - Unions"}},{path:"plugins",component:Q,data:{title:"GraphQL + TypeScript - Plugins"}},{path:"interfaces",component:T,data:{title:"GraphQL + TypeScript - Interfaces"}},{path:"mapped-types",component:q,data:{title:"GraphQL + TypeScript - Mapped types"}},{path:"cli-plugin",component:p,data:{title:"GraphQL + TypeScript - CLI Plugin"}},{path:"generating-sdl",component:U,data:{title:"GraphQL + TypeScript - Generating SDL"}}];let Y=(()=>{class e{}return e.\u0275mod=s.Db({type:e}),e.\u0275inj=s.Cb({factory:function(t){return new(t||e)},imports:[[n.b,r.a,a.g.forChild(V)]]}),e})()}}]);